// Code generated by make; DO NOT EDIT.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v4.25.2
// source: csi.proto

package csi

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BlockMetadataType int32

const (
	BlockMetadataType_UNKNOWN BlockMetadataType = 0
	// The FIXED_LENGTH value indicates that data ranges are
	// returned in fixed size blocks.
	BlockMetadataType_FIXED_LENGTH BlockMetadataType = 1
	// The VARIABLE_LENGTH value indicates that data ranges
	// are returned in potentially variable sized extents.
	BlockMetadataType_VARIABLE_LENGTH BlockMetadataType = 2
)

// Enum value maps for BlockMetadataType.
var (
	BlockMetadataType_name = map[int32]string{
		0: "UNKNOWN",
		1: "FIXED_LENGTH",
		2: "VARIABLE_LENGTH",
	}
	BlockMetadataType_value = map[string]int32{
		"UNKNOWN":         0,
		"FIXED_LENGTH":    1,
		"VARIABLE_LENGTH": 2,
	}
)

func (x BlockMetadataType) Enum() *BlockMetadataType {
	p := new(BlockMetadataType)
	*p = x
	return p
}

func (x BlockMetadataType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BlockMetadataType) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[0].Descriptor()
}

func (BlockMetadataType) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[0]
}

func (x BlockMetadataType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BlockMetadataType.Descriptor instead.
func (BlockMetadataType) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{0}
}

type PluginCapability_Service_Type int32

const (
	PluginCapability_Service_UNKNOWN PluginCapability_Service_Type = 0
	// CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
	// the ControllerService. Plugins SHOULD provide this capability.
	// In rare cases certain plugins MAY wish to omit the
	// ControllerService entirely from their implementation, but such
	// SHOULD NOT be the common case.
	// The presence of this capability determines whether the CO will
	// attempt to invoke the REQUIRED ControllerService RPCs, as well
	// as specific RPCs as indicated by ControllerGetCapabilities.
	PluginCapability_Service_CONTROLLER_SERVICE PluginCapability_Service_Type = 1
	// VOLUME_ACCESSIBILITY_CONSTRAINTS indicates that the volumes for
	// this plugin MAY NOT be equally accessible by all nodes in the
	// cluster. The CO MUST use the topology information returned by
	// CreateVolumeRequest along with the topology information
	// returned by NodeGetInfo to ensure that a given volume is
	// accessible from a given node when scheduling workloads.
	PluginCapability_Service_VOLUME_ACCESSIBILITY_CONSTRAINTS PluginCapability_Service_Type = 2
	// GROUP_CONTROLLER_SERVICE indicates that the Plugin provides
	// RPCs for operating on groups of volumes. Plugins MAY provide
	// this capability.
	// The presence of this capability determines whether the CO will
	// attempt to invoke the REQUIRED GroupController service RPCs, as
	// well as specific RPCs as indicated by
	// GroupControllerGetCapabilities.
	PluginCapability_Service_GROUP_CONTROLLER_SERVICE PluginCapability_Service_Type = 3
	// SNAPSHOT_METADATA_SERVICE indicates that the Plugin provides
	// RPCs to retrieve metadata on the allocated blocks of a single
	// snapshot, or the changed blocks between a pair of snapshots of
	// the same block volume.
	// The presence of this capability determines whether the CO will
	// attempt to invoke the OPTIONAL SnapshotMetadata service RPCs.
	PluginCapability_Service_SNAPSHOT_METADATA_SERVICE PluginCapability_Service_Type = 4
)

// Enum value maps for PluginCapability_Service_Type.
var (
	PluginCapability_Service_Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "CONTROLLER_SERVICE",
		2: "VOLUME_ACCESSIBILITY_CONSTRAINTS",
		3: "GROUP_CONTROLLER_SERVICE",
		4: "SNAPSHOT_METADATA_SERVICE",
	}
	PluginCapability_Service_Type_value = map[string]int32{
		"UNKNOWN":                          0,
		"CONTROLLER_SERVICE":               1,
		"VOLUME_ACCESSIBILITY_CONSTRAINTS": 2,
		"GROUP_CONTROLLER_SERVICE":         3,
		"SNAPSHOT_METADATA_SERVICE":        4,
	}
)

func (x PluginCapability_Service_Type) Enum() *PluginCapability_Service_Type {
	p := new(PluginCapability_Service_Type)
	*p = x
	return p
}

func (x PluginCapability_Service_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PluginCapability_Service_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[1].Descriptor()
}

func (PluginCapability_Service_Type) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[1]
}

func (x PluginCapability_Service_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PluginCapability_Service_Type.Descriptor instead.
func (PluginCapability_Service_Type) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{4, 0, 0}
}

type PluginCapability_VolumeExpansion_Type int32

const (
	PluginCapability_VolumeExpansion_UNKNOWN PluginCapability_VolumeExpansion_Type = 0
	// ONLINE indicates that volumes may be expanded when published to
	// a node. When a Plugin implements this capability it MUST
	// implement either the EXPAND_VOLUME controller capability or the
	// EXPAND_VOLUME node capability or both. When a plugin supports
	// ONLINE volume expansion and also has the EXPAND_VOLUME
	// controller capability then the plugin MUST support expansion of
	// volumes currently published and available on a node. When a
	// plugin supports ONLINE volume expansion and also has the
	// EXPAND_VOLUME node capability then the plugin MAY support
	// expansion of node-published volume via NodeExpandVolume.
	//
	// Example 1: Given a shared filesystem volume (e.g. GlusterFs),
	//
	//	the Plugin may set the ONLINE volume expansion capability and
	//	implement ControllerExpandVolume but not NodeExpandVolume.
	//
	// Example 2: Given a block storage volume type (e.g. EBS), the
	//
	//	Plugin may set the ONLINE volume expansion capability and
	//	implement both ControllerExpandVolume and NodeExpandVolume.
	//
	// Example 3: Given a Plugin that supports volume expansion only
	//
	//	upon a node, the Plugin may set the ONLINE volume
	//	expansion capability and implement NodeExpandVolume but not
	//	ControllerExpandVolume.
	PluginCapability_VolumeExpansion_ONLINE PluginCapability_VolumeExpansion_Type = 1
	// OFFLINE indicates that volumes currently published and
	// available on a node SHALL NOT be expanded via
	// ControllerExpandVolume. When a plugin supports OFFLINE volume
	// expansion it MUST implement either the EXPAND_VOLUME controller
	// capability or both the EXPAND_VOLUME controller capability and
	// the EXPAND_VOLUME node capability.
	//
	// Example 1: Given a block storage volume type (e.g. Azure Disk)
	//
	//	that does not support expansion of "node-attached" (i.e.
	//	controller-published) volumes, the Plugin may indicate
	//	OFFLINE volume expansion support and implement both
	//	ControllerExpandVolume and NodeExpandVolume.
	PluginCapability_VolumeExpansion_OFFLINE PluginCapability_VolumeExpansion_Type = 2
)

// Enum value maps for PluginCapability_VolumeExpansion_Type.
var (
	PluginCapability_VolumeExpansion_Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "ONLINE",
		2: "OFFLINE",
	}
	PluginCapability_VolumeExpansion_Type_value = map[string]int32{
		"UNKNOWN": 0,
		"ONLINE":  1,
		"OFFLINE": 2,
	}
)

func (x PluginCapability_VolumeExpansion_Type) Enum() *PluginCapability_VolumeExpansion_Type {
	p := new(PluginCapability_VolumeExpansion_Type)
	*p = x
	return p
}

func (x PluginCapability_VolumeExpansion_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PluginCapability_VolumeExpansion_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[2].Descriptor()
}

func (PluginCapability_VolumeExpansion_Type) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[2]
}

func (x PluginCapability_VolumeExpansion_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PluginCapability_VolumeExpansion_Type.Descriptor instead.
func (PluginCapability_VolumeExpansion_Type) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{4, 1, 0}
}

type VolumeCapability_AccessMode_Mode int32

const (
	VolumeCapability_AccessMode_UNKNOWN VolumeCapability_AccessMode_Mode = 0
	// Can only be published once as read/write on a single node, at
	// any given time.
	VolumeCapability_AccessMode_SINGLE_NODE_WRITER VolumeCapability_AccessMode_Mode = 1
	// Can only be published once as readonly on a single node, at
	// any given time.
	VolumeCapability_AccessMode_SINGLE_NODE_READER_ONLY VolumeCapability_AccessMode_Mode = 2
	// Can be published as readonly at multiple nodes simultaneously.
	VolumeCapability_AccessMode_MULTI_NODE_READER_ONLY VolumeCapability_AccessMode_Mode = 3
	// Can be published at multiple nodes simultaneously. Only one of
	// the node can be used as read/write. The rest will be readonly.
	VolumeCapability_AccessMode_MULTI_NODE_SINGLE_WRITER VolumeCapability_AccessMode_Mode = 4
	// Can be published as read/write at multiple nodes
	// simultaneously.
	VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER VolumeCapability_AccessMode_Mode = 5
	// Can only be published once as read/write at a single workload
	// on a single node, at any given time. SHOULD be used instead of
	// SINGLE_NODE_WRITER for COs using the experimental
	// SINGLE_NODE_MULTI_WRITER capability.
	VolumeCapability_AccessMode_SINGLE_NODE_SINGLE_WRITER VolumeCapability_AccessMode_Mode = 6
	// Can be published as read/write at multiple workloads on a
	// single node simultaneously. SHOULD be used instead of
	// SINGLE_NODE_WRITER for COs using the experimental
	// SINGLE_NODE_MULTI_WRITER capability.
	VolumeCapability_AccessMode_SINGLE_NODE_MULTI_WRITER VolumeCapability_AccessMode_Mode = 7
)

// Enum value maps for VolumeCapability_AccessMode_Mode.
var (
	VolumeCapability_AccessMode_Mode_name = map[int32]string{
		0: "UNKNOWN",
		1: "SINGLE_NODE_WRITER",
		2: "SINGLE_NODE_READER_ONLY",
		3: "MULTI_NODE_READER_ONLY",
		4: "MULTI_NODE_SINGLE_WRITER",
		5: "MULTI_NODE_MULTI_WRITER",
		6: "SINGLE_NODE_SINGLE_WRITER",
		7: "SINGLE_NODE_MULTI_WRITER",
	}
	VolumeCapability_AccessMode_Mode_value = map[string]int32{
		"UNKNOWN":                   0,
		"SINGLE_NODE_WRITER":        1,
		"SINGLE_NODE_READER_ONLY":   2,
		"MULTI_NODE_READER_ONLY":    3,
		"MULTI_NODE_SINGLE_WRITER":  4,
		"MULTI_NODE_MULTI_WRITER":   5,
		"SINGLE_NODE_SINGLE_WRITER": 6,
		"SINGLE_NODE_MULTI_WRITER":  7,
	}
)

func (x VolumeCapability_AccessMode_Mode) Enum() *VolumeCapability_AccessMode_Mode {
	p := new(VolumeCapability_AccessMode_Mode)
	*p = x
	return p
}

func (x VolumeCapability_AccessMode_Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VolumeCapability_AccessMode_Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[3].Descriptor()
}

func (VolumeCapability_AccessMode_Mode) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[3]
}

func (x VolumeCapability_AccessMode_Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VolumeCapability_AccessMode_Mode.Descriptor instead.
func (VolumeCapability_AccessMode_Mode) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{10, 2, 0}
}

type ControllerServiceCapability_RPC_Type int32

const (
	ControllerServiceCapability_RPC_UNKNOWN                  ControllerServiceCapability_RPC_Type = 0
	ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME     ControllerServiceCapability_RPC_Type = 1
	ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME ControllerServiceCapability_RPC_Type = 2
	ControllerServiceCapability_RPC_LIST_VOLUMES             ControllerServiceCapability_RPC_Type = 3
	ControllerServiceCapability_RPC_GET_CAPACITY             ControllerServiceCapability_RPC_Type = 4
	// Currently the only way to consume a snapshot is to create
	// a volume from it. Therefore plugins supporting
	// CREATE_DELETE_SNAPSHOT MUST support creating volume from
	// snapshot.
	ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT ControllerServiceCapability_RPC_Type = 5
	ControllerServiceCapability_RPC_LIST_SNAPSHOTS         ControllerServiceCapability_RPC_Type = 6
	// Plugins supporting volume cloning at the storage level MAY
	// report this capability. The source volume MUST be managed by
	// the same plugin. Not all volume sources and parameters
	// combinations MAY work.
	ControllerServiceCapability_RPC_CLONE_VOLUME ControllerServiceCapability_RPC_Type = 7
	// Indicates the SP supports ControllerPublishVolume.readonly
	// field.
	ControllerServiceCapability_RPC_PUBLISH_READONLY ControllerServiceCapability_RPC_Type = 8
	// See VolumeExpansion for details.
	ControllerServiceCapability_RPC_EXPAND_VOLUME ControllerServiceCapability_RPC_Type = 9
	// Indicates the SP supports the
	// ListVolumesResponse.entry.published_node_ids field and the
	// ControllerGetVolumeResponse.published_node_ids field.
	// The SP MUST also support PUBLISH_UNPUBLISH_VOLUME.
	ControllerServiceCapability_RPC_LIST_VOLUMES_PUBLISHED_NODES ControllerServiceCapability_RPC_Type = 10
	// Indicates that the Controller service can report volume
	// conditions.
	// An SP MAY implement `VolumeCondition` in only the Controller
	// Plugin, only the Node Plugin, or both.
	// If `VolumeCondition` is implemented in both the Controller and
	// Node Plugins, it SHALL report from different perspectives.
	// If for some reason Controller and Node Plugins report
	// misaligned volume conditions, CO SHALL assume the worst case
	// is the truth.
	// Note that, for alpha, `VolumeCondition` is intended be
	// informative for humans only, not for automation.
	ControllerServiceCapability_RPC_VOLUME_CONDITION ControllerServiceCapability_RPC_Type = 11
	// Indicates the SP supports the ControllerGetVolume RPC.
	// This enables COs to, for example, fetch per volume
	// condition after a volume is provisioned.
	ControllerServiceCapability_RPC_GET_VOLUME ControllerServiceCapability_RPC_Type = 12
	// Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
	// SINGLE_NODE_MULTI_WRITER access modes.
	// These access modes are intended to replace the
	// SINGLE_NODE_WRITER access mode to clarify the number of writers
	// for a volume on a single node. Plugins MUST accept and allow
	// use of the SINGLE_NODE_WRITER access mode when either
	// SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
	// supported, in order to permit older COs to continue working.
	ControllerServiceCapability_RPC_SINGLE_NODE_MULTI_WRITER ControllerServiceCapability_RPC_Type = 13
	// Indicates the SP supports modifying volume with mutable
	// parameters. See ControllerModifyVolume for details.
	ControllerServiceCapability_RPC_MODIFY_VOLUME ControllerServiceCapability_RPC_Type = 14
	// Indicates the SP supports the GetSnapshot RPC.
	// This enables COs to fetch an existing snapshot.
	ControllerServiceCapability_RPC_GET_SNAPSHOT ControllerServiceCapability_RPC_Type = 15
)

// Enum value maps for ControllerServiceCapability_RPC_Type.
var (
	ControllerServiceCapability_RPC_Type_name = map[int32]string{
		0:  "UNKNOWN",
		1:  "CREATE_DELETE_VOLUME",
		2:  "PUBLISH_UNPUBLISH_VOLUME",
		3:  "LIST_VOLUMES",
		4:  "GET_CAPACITY",
		5:  "CREATE_DELETE_SNAPSHOT",
		6:  "LIST_SNAPSHOTS",
		7:  "CLONE_VOLUME",
		8:  "PUBLISH_READONLY",
		9:  "EXPAND_VOLUME",
		10: "LIST_VOLUMES_PUBLISHED_NODES",
		11: "VOLUME_CONDITION",
		12: "GET_VOLUME",
		13: "SINGLE_NODE_MULTI_WRITER",
		14: "MODIFY_VOLUME",
		15: "GET_SNAPSHOT",
	}
	ControllerServiceCapability_RPC_Type_value = map[string]int32{
		"UNKNOWN":                      0,
		"CREATE_DELETE_VOLUME":         1,
		"PUBLISH_UNPUBLISH_VOLUME":     2,
		"LIST_VOLUMES":                 3,
		"GET_CAPACITY":                 4,
		"CREATE_DELETE_SNAPSHOT":       5,
		"LIST_SNAPSHOTS":               6,
		"CLONE_VOLUME":                 7,
		"PUBLISH_READONLY":             8,
		"EXPAND_VOLUME":                9,
		"LIST_VOLUMES_PUBLISHED_NODES": 10,
		"VOLUME_CONDITION":             11,
		"GET_VOLUME":                   12,
		"SINGLE_NODE_MULTI_WRITER":     13,
		"MODIFY_VOLUME":                14,
		"GET_SNAPSHOT":                 15,
	}
)

func (x ControllerServiceCapability_RPC_Type) Enum() *ControllerServiceCapability_RPC_Type {
	p := new(ControllerServiceCapability_RPC_Type)
	*p = x
	return p
}

func (x ControllerServiceCapability_RPC_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ControllerServiceCapability_RPC_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[4].Descriptor()
}

func (ControllerServiceCapability_RPC_Type) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[4]
}

func (x ControllerServiceCapability_RPC_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ControllerServiceCapability_RPC_Type.Descriptor instead.
func (ControllerServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{33, 0, 0}
}

type VolumeUsage_Unit int32

const (
	VolumeUsage_UNKNOWN VolumeUsage_Unit = 0
	VolumeUsage_BYTES   VolumeUsage_Unit = 1
	VolumeUsage_INODES  VolumeUsage_Unit = 2
)

// Enum value maps for VolumeUsage_Unit.
var (
	VolumeUsage_Unit_name = map[int32]string{
		0: "UNKNOWN",
		1: "BYTES",
		2: "INODES",
	}
	VolumeUsage_Unit_value = map[string]int32{
		"UNKNOWN": 0,
		"BYTES":   1,
		"INODES":  2,
	}
)

func (x VolumeUsage_Unit) Enum() *VolumeUsage_Unit {
	p := new(VolumeUsage_Unit)
	*p = x
	return p
}

func (x VolumeUsage_Unit) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VolumeUsage_Unit) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[5].Descriptor()
}

func (VolumeUsage_Unit) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[5]
}

func (x VolumeUsage_Unit) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VolumeUsage_Unit.Descriptor instead.
func (VolumeUsage_Unit) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{55, 0}
}

type NodeServiceCapability_RPC_Type int32

const (
	NodeServiceCapability_RPC_UNKNOWN              NodeServiceCapability_RPC_Type = 0
	NodeServiceCapability_RPC_STAGE_UNSTAGE_VOLUME NodeServiceCapability_RPC_Type = 1
	// If Plugin implements GET_VOLUME_STATS capability
	// then it MUST implement NodeGetVolumeStats RPC
	// call for fetching volume statistics.
	NodeServiceCapability_RPC_GET_VOLUME_STATS NodeServiceCapability_RPC_Type = 2
	// See VolumeExpansion for details.
	NodeServiceCapability_RPC_EXPAND_VOLUME NodeServiceCapability_RPC_Type = 3
	// Indicates that the Node service can report volume conditions.
	// An SP MAY implement `VolumeCondition` in only the Node
	// Plugin, only the Controller Plugin, or both.
	// If `VolumeCondition` is implemented in both the Node and
	// Controller Plugins, it SHALL report from different
	// perspectives.
	// If for some reason Node and Controller Plugins report
	// misaligned volume conditions, CO SHALL assume the worst case
	// is the truth.
	// Note that, for alpha, `VolumeCondition` is intended to be
	// informative for humans only, not for automation.
	NodeServiceCapability_RPC_VOLUME_CONDITION NodeServiceCapability_RPC_Type = 4
	// Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
	// SINGLE_NODE_MULTI_WRITER access modes.
	// These access modes are intended to replace the
	// SINGLE_NODE_WRITER access mode to clarify the number of writers
	// for a volume on a single node. Plugins MUST accept and allow
	// use of the SINGLE_NODE_WRITER access mode (subject to the
	// processing rules for NodePublishVolume), when either
	// SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
	// supported, in order to permit older COs to continue working.
	NodeServiceCapability_RPC_SINGLE_NODE_MULTI_WRITER NodeServiceCapability_RPC_Type = 5
	// Indicates that Node service supports mounting volumes
	// with provided volume group identifier during node stage
	// or node publish RPC calls.
	NodeServiceCapability_RPC_VOLUME_MOUNT_GROUP NodeServiceCapability_RPC_Type = 6
)

// Enum value maps for NodeServiceCapability_RPC_Type.
var (
	NodeServiceCapability_RPC_Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "STAGE_UNSTAGE_VOLUME",
		2: "GET_VOLUME_STATS",
		3: "EXPAND_VOLUME",
		4: "VOLUME_CONDITION",
		5: "SINGLE_NODE_MULTI_WRITER",
		6: "VOLUME_MOUNT_GROUP",
	}
	NodeServiceCapability_RPC_Type_value = map[string]int32{
		"UNKNOWN":                  0,
		"STAGE_UNSTAGE_VOLUME":     1,
		"GET_VOLUME_STATS":         2,
		"EXPAND_VOLUME":            3,
		"VOLUME_CONDITION":         4,
		"SINGLE_NODE_MULTI_WRITER": 5,
		"VOLUME_MOUNT_GROUP":       6,
	}
)

func (x NodeServiceCapability_RPC_Type) Enum() *NodeServiceCapability_RPC_Type {
	p := new(NodeServiceCapability_RPC_Type)
	*p = x
	return p
}

func (x NodeServiceCapability_RPC_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeServiceCapability_RPC_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[6].Descriptor()
}

func (NodeServiceCapability_RPC_Type) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[6]
}

func (x NodeServiceCapability_RPC_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeServiceCapability_RPC_Type.Descriptor instead.
func (NodeServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{59, 0, 0}
}

type GroupControllerServiceCapability_RPC_Type int32

const (
	GroupControllerServiceCapability_RPC_UNKNOWN GroupControllerServiceCapability_RPC_Type = 0
	// Indicates that the group controller plugin supports
	// creating, deleting, and getting details of a volume
	// group snapshot.
	GroupControllerServiceCapability_RPC_CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT GroupControllerServiceCapability_RPC_Type = 1
)

// Enum value maps for GroupControllerServiceCapability_RPC_Type.
var (
	GroupControllerServiceCapability_RPC_Type_name = map[int32]string{
		0: "UNKNOWN",
		1: "CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT",
	}
	GroupControllerServiceCapability_RPC_Type_value = map[string]int32{
		"UNKNOWN": 0,
		"CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT": 1,
	}
)

func (x GroupControllerServiceCapability_RPC_Type) Enum() *GroupControllerServiceCapability_RPC_Type {
	p := new(GroupControllerServiceCapability_RPC_Type)
	*p = x
	return p
}

func (x GroupControllerServiceCapability_RPC_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GroupControllerServiceCapability_RPC_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_csi_proto_enumTypes[7].Descriptor()
}

func (GroupControllerServiceCapability_RPC_Type) Type() protoreflect.EnumType {
	return &file_csi_proto_enumTypes[7]
}

func (x GroupControllerServiceCapability_RPC_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GroupControllerServiceCapability_RPC_Type.Descriptor instead.
func (GroupControllerServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{66, 0, 0}
}

type GetPluginInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPluginInfoRequest) Reset() {
	*x = GetPluginInfoRequest{}
	mi := &file_csi_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPluginInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPluginInfoRequest) ProtoMessage() {}

func (x *GetPluginInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPluginInfoRequest.ProtoReflect.Descriptor instead.
func (*GetPluginInfoRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{0}
}

type GetPluginInfoResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name MUST follow domain name notation format
	// (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
	// include the plugin's host company name and the plugin name,
	// to minimize the possibility of collisions. It MUST be 63
	// characters or less, beginning and ending with an alphanumeric
	// character ([a-z0-9A-Z]) with dashes (-), dots (.), and
	// alphanumerics between. This field is REQUIRED.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field is REQUIRED. Value of this field is opaque to the CO.
	VendorVersion string `protobuf:"bytes,2,opt,name=vendor_version,json=vendorVersion,proto3" json:"vendor_version,omitempty"`
	// This field is OPTIONAL. Values are opaque to the CO.
	Manifest      map[string]string `protobuf:"bytes,3,rep,name=manifest,proto3" json:"manifest,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPluginInfoResponse) Reset() {
	*x = GetPluginInfoResponse{}
	mi := &file_csi_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPluginInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPluginInfoResponse) ProtoMessage() {}

func (x *GetPluginInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPluginInfoResponse.ProtoReflect.Descriptor instead.
func (*GetPluginInfoResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{1}
}

func (x *GetPluginInfoResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetPluginInfoResponse) GetVendorVersion() string {
	if x != nil {
		return x.VendorVersion
	}
	return ""
}

func (x *GetPluginInfoResponse) GetManifest() map[string]string {
	if x != nil {
		return x.Manifest
	}
	return nil
}

type GetPluginCapabilitiesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPluginCapabilitiesRequest) Reset() {
	*x = GetPluginCapabilitiesRequest{}
	mi := &file_csi_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPluginCapabilitiesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPluginCapabilitiesRequest) ProtoMessage() {}

func (x *GetPluginCapabilitiesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPluginCapabilitiesRequest.ProtoReflect.Descriptor instead.
func (*GetPluginCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{2}
}

type GetPluginCapabilitiesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// All the capabilities that the controller service supports. This
	// field is OPTIONAL.
	Capabilities  []*PluginCapability `protobuf:"bytes,1,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPluginCapabilitiesResponse) Reset() {
	*x = GetPluginCapabilitiesResponse{}
	mi := &file_csi_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPluginCapabilitiesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPluginCapabilitiesResponse) ProtoMessage() {}

func (x *GetPluginCapabilitiesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPluginCapabilitiesResponse.ProtoReflect.Descriptor instead.
func (*GetPluginCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{3}
}

func (x *GetPluginCapabilitiesResponse) GetCapabilities() []*PluginCapability {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

// Specifies a capability of the plugin.
type PluginCapability struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*PluginCapability_Service_
	//	*PluginCapability_VolumeExpansion_
	Type          isPluginCapability_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginCapability) Reset() {
	*x = PluginCapability{}
	mi := &file_csi_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginCapability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginCapability) ProtoMessage() {}

func (x *PluginCapability) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginCapability.ProtoReflect.Descriptor instead.
func (*PluginCapability) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{4}
}

func (x *PluginCapability) GetType() isPluginCapability_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *PluginCapability) GetService() *PluginCapability_Service {
	if x != nil {
		if x, ok := x.Type.(*PluginCapability_Service_); ok {
			return x.Service
		}
	}
	return nil
}

func (x *PluginCapability) GetVolumeExpansion() *PluginCapability_VolumeExpansion {
	if x != nil {
		if x, ok := x.Type.(*PluginCapability_VolumeExpansion_); ok {
			return x.VolumeExpansion
		}
	}
	return nil
}

type isPluginCapability_Type interface {
	isPluginCapability_Type()
}

type PluginCapability_Service_ struct {
	// Service that the plugin supports.
	Service *PluginCapability_Service `protobuf:"bytes,1,opt,name=service,proto3,oneof"`
}

type PluginCapability_VolumeExpansion_ struct {
	VolumeExpansion *PluginCapability_VolumeExpansion `protobuf:"bytes,2,opt,name=volume_expansion,json=volumeExpansion,proto3,oneof"`
}

func (*PluginCapability_Service_) isPluginCapability_Type() {}

func (*PluginCapability_VolumeExpansion_) isPluginCapability_Type() {}

type ProbeRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProbeRequest) Reset() {
	*x = ProbeRequest{}
	mi := &file_csi_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProbeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProbeRequest) ProtoMessage() {}

func (x *ProbeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProbeRequest.ProtoReflect.Descriptor instead.
func (*ProbeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{5}
}

type ProbeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Readiness allows a plugin to report its initialization status back
	// to the CO. Initialization for some plugins MAY be time consuming
	// and it is important for a CO to distinguish between the following
	// cases:
	//
	//  1. The plugin is in an unhealthy state and MAY need restarting. In
	//     this case a gRPC error code SHALL be returned.
	//  2. The plugin is still initializing, but is otherwise perfectly
	//     healthy. In this case a successful response SHALL be returned
	//     with a readiness value of `false`. Calls to the plugin's
	//     Controller and/or Node services MAY fail due to an incomplete
	//     initialization state.
	//  3. The plugin has finished initializing and is ready to service
	//     calls to its Controller and/or Node services. A successful
	//     response is returned with a readiness value of `true`.
	//
	// This field is OPTIONAL. If not present, the caller SHALL assume
	// that the plugin is in a ready state and is accepting calls to its
	// Controller and/or Node services (according to the plugin's reported
	// capabilities).
	Ready         *wrappers.BoolValue `protobuf:"bytes,1,opt,name=ready,proto3" json:"ready,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProbeResponse) Reset() {
	*x = ProbeResponse{}
	mi := &file_csi_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProbeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProbeResponse) ProtoMessage() {}

func (x *ProbeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProbeResponse.ProtoReflect.Descriptor instead.
func (*ProbeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{6}
}

func (x *ProbeResponse) GetReady() *wrappers.BoolValue {
	if x != nil {
		return x.Ready
	}
	return nil
}

type CreateVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The suggested name for the storage space. This field is REQUIRED.
	// It serves two purposes:
	//  1. Idempotency - This name is generated by the CO to achieve
	//     idempotency.  The Plugin SHOULD ensure that multiple
	//     `CreateVolume` calls for the same name do not result in more
	//     than one piece of storage provisioned corresponding to that
	//     name. If a Plugin is unable to enforce idempotency, the CO's
	//     error recovery logic could result in multiple (unused) volumes
	//     being provisioned.
	//     In the case of error, the CO MUST handle the gRPC error codes
	//     per the recovery behavior defined in the "CreateVolume Errors"
	//     section below.
	//     The CO is responsible for cleaning up volumes it provisioned
	//     that it no longer needs. If the CO is uncertain whether a volume
	//     was provisioned or not when a `CreateVolume` call fails, the CO
	//     MAY call `CreateVolume` again, with the same name, to ensure the
	//     volume exists and to retrieve the volume's `volume_id` (unless
	//     otherwise prohibited by "CreateVolume Errors").
	//  2. Suggested name - Some storage systems allow callers to specify
	//     an identifier by which to refer to the newly provisioned
	//     storage. If a storage system supports this, it can optionally
	//     use this name as the identifier for the new volume.
	//
	// Any Unicode string that conforms to the length limit is allowed
	// except those containing the following banned characters:
	// U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
	// (These are control characters other than commonly used whitespace.)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field is OPTIONAL. This allows the CO to specify the capacity
	// requirement of the volume to be provisioned. If not specified, the
	// Plugin MAY choose an implementation-defined capacity range. If
	// specified it MUST always be honored, even when creating volumes
	// from a source; which MAY force some backends to internally extend
	// the volume after creating it.
	CapacityRange *CapacityRange `protobuf:"bytes,2,opt,name=capacity_range,json=capacityRange,proto3" json:"capacity_range,omitempty"`
	// The capabilities that the provisioned volume MUST have. SP MUST
	// provision a volume that will satisfy ALL of the capabilities
	// specified in this list. Otherwise SP MUST return the appropriate
	// gRPC error code.
	// The Plugin MUST assume that the CO MAY use the provisioned volume
	// with ANY of the capabilities specified in this list.
	// For example, a CO MAY specify two volume capabilities: one with
	// access mode SINGLE_NODE_WRITER and another with access mode
	// MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
	// provisioned volume can be used in either mode.
	// This also enables the CO to do early validation: If ANY of the
	// specified volume capabilities are not supported by the SP, the call
	// MUST return the appropriate gRPC error code.
	// This field is REQUIRED.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,3,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// Plugin specific creation-time parameters passed in as opaque
	// key-value pairs. This field is OPTIONAL. The Plugin is responsible
	// for parsing and validating these parameters. COs will treat
	// these as opaque.
	Parameters map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Secrets required by plugin to complete volume creation request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If specified, the new volume will be pre-populated with data from
	// this source. This field is OPTIONAL.
	VolumeContentSource *VolumeContentSource `protobuf:"bytes,6,opt,name=volume_content_source,json=volumeContentSource,proto3" json:"volume_content_source,omitempty"`
	// Specifies where (regions, zones, racks, etc.) the provisioned
	// volume MUST be accessible from.
	// An SP SHALL advertise the requirements for topological
	// accessibility information in documentation. COs SHALL only specify
	// topological accessibility information supported by the SP.
	// This field is OPTIONAL.
	// This field SHALL NOT be specified unless the SP has the
	// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
	// If this field is not specified and the SP has the
	// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
	// choose where the provisioned volume is accessible from.
	AccessibilityRequirements *TopologyRequirement `protobuf:"bytes,7,opt,name=accessibility_requirements,json=accessibilityRequirements,proto3" json:"accessibility_requirements,omitempty"`
	// Plugins MUST treat these
	// as if they take precedence over the parameters field.
	// This field SHALL NOT be specified unless the SP has the
	// MODIFY_VOLUME plugin capability.
	MutableParameters map[string]string `protobuf:"bytes,8,rep,name=mutable_parameters,json=mutableParameters,proto3" json:"mutable_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *CreateVolumeRequest) Reset() {
	*x = CreateVolumeRequest{}
	mi := &file_csi_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateVolumeRequest) ProtoMessage() {}

func (x *CreateVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateVolumeRequest.ProtoReflect.Descriptor instead.
func (*CreateVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{7}
}

func (x *CreateVolumeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateVolumeRequest) GetCapacityRange() *CapacityRange {
	if x != nil {
		return x.CapacityRange
	}
	return nil
}

func (x *CreateVolumeRequest) GetVolumeCapabilities() []*VolumeCapability {
	if x != nil {
		return x.VolumeCapabilities
	}
	return nil
}

func (x *CreateVolumeRequest) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *CreateVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *CreateVolumeRequest) GetVolumeContentSource() *VolumeContentSource {
	if x != nil {
		return x.VolumeContentSource
	}
	return nil
}

func (x *CreateVolumeRequest) GetAccessibilityRequirements() *TopologyRequirement {
	if x != nil {
		return x.AccessibilityRequirements
	}
	return nil
}

func (x *CreateVolumeRequest) GetMutableParameters() map[string]string {
	if x != nil {
		return x.MutableParameters
	}
	return nil
}

// Specifies what source the volume will be created from. One of the
// type fields MUST be specified.
type VolumeContentSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*VolumeContentSource_Snapshot
	//	*VolumeContentSource_Volume
	Type          isVolumeContentSource_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeContentSource) Reset() {
	*x = VolumeContentSource{}
	mi := &file_csi_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeContentSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeContentSource) ProtoMessage() {}

func (x *VolumeContentSource) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeContentSource.ProtoReflect.Descriptor instead.
func (*VolumeContentSource) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{8}
}

func (x *VolumeContentSource) GetType() isVolumeContentSource_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *VolumeContentSource) GetSnapshot() *VolumeContentSource_SnapshotSource {
	if x != nil {
		if x, ok := x.Type.(*VolumeContentSource_Snapshot); ok {
			return x.Snapshot
		}
	}
	return nil
}

func (x *VolumeContentSource) GetVolume() *VolumeContentSource_VolumeSource {
	if x != nil {
		if x, ok := x.Type.(*VolumeContentSource_Volume); ok {
			return x.Volume
		}
	}
	return nil
}

type isVolumeContentSource_Type interface {
	isVolumeContentSource_Type()
}

type VolumeContentSource_Snapshot struct {
	Snapshot *VolumeContentSource_SnapshotSource `protobuf:"bytes,1,opt,name=snapshot,proto3,oneof"`
}

type VolumeContentSource_Volume struct {
	Volume *VolumeContentSource_VolumeSource `protobuf:"bytes,2,opt,name=volume,proto3,oneof"`
}

func (*VolumeContentSource_Snapshot) isVolumeContentSource_Type() {}

func (*VolumeContentSource_Volume) isVolumeContentSource_Type() {}

type CreateVolumeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Contains all attributes of the newly created volume that are
	// relevant to the CO along with information required by the Plugin
	// to uniquely identify the volume. This field is REQUIRED.
	Volume        *Volume `protobuf:"bytes,1,opt,name=volume,proto3" json:"volume,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateVolumeResponse) Reset() {
	*x = CreateVolumeResponse{}
	mi := &file_csi_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateVolumeResponse) ProtoMessage() {}

func (x *CreateVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateVolumeResponse.ProtoReflect.Descriptor instead.
func (*CreateVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{9}
}

func (x *CreateVolumeResponse) GetVolume() *Volume {
	if x != nil {
		return x.Volume
	}
	return nil
}

// Specify a capability of a volume.
type VolumeCapability struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies what API the volume will be accessed using. One of the
	// following fields MUST be specified.
	//
	// Types that are valid to be assigned to AccessType:
	//
	//	*VolumeCapability_Block
	//	*VolumeCapability_Mount
	AccessType isVolumeCapability_AccessType `protobuf_oneof:"access_type"`
	// This is a REQUIRED field.
	AccessMode    *VolumeCapability_AccessMode `protobuf:"bytes,3,opt,name=access_mode,json=accessMode,proto3" json:"access_mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeCapability) Reset() {
	*x = VolumeCapability{}
	mi := &file_csi_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeCapability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeCapability) ProtoMessage() {}

func (x *VolumeCapability) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeCapability.ProtoReflect.Descriptor instead.
func (*VolumeCapability) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{10}
}

func (x *VolumeCapability) GetAccessType() isVolumeCapability_AccessType {
	if x != nil {
		return x.AccessType
	}
	return nil
}

func (x *VolumeCapability) GetBlock() *VolumeCapability_BlockVolume {
	if x != nil {
		if x, ok := x.AccessType.(*VolumeCapability_Block); ok {
			return x.Block
		}
	}
	return nil
}

func (x *VolumeCapability) GetMount() *VolumeCapability_MountVolume {
	if x != nil {
		if x, ok := x.AccessType.(*VolumeCapability_Mount); ok {
			return x.Mount
		}
	}
	return nil
}

func (x *VolumeCapability) GetAccessMode() *VolumeCapability_AccessMode {
	if x != nil {
		return x.AccessMode
	}
	return nil
}

type isVolumeCapability_AccessType interface {
	isVolumeCapability_AccessType()
}

type VolumeCapability_Block struct {
	Block *VolumeCapability_BlockVolume `protobuf:"bytes,1,opt,name=block,proto3,oneof"`
}

type VolumeCapability_Mount struct {
	Mount *VolumeCapability_MountVolume `protobuf:"bytes,2,opt,name=mount,proto3,oneof"`
}

func (*VolumeCapability_Block) isVolumeCapability_AccessType() {}

func (*VolumeCapability_Mount) isVolumeCapability_AccessType() {}

// The capacity of the storage space in bytes. To specify an exact size,
// `required_bytes` and `limit_bytes` SHALL be set to the same value. At
// least one of the these fields MUST be specified.
type CapacityRange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Volume MUST be at least this big. This field is OPTIONAL.
	// A value of 0 is equal to an unspecified field value.
	// The value of this field MUST NOT be negative.
	RequiredBytes int64 `protobuf:"varint,1,opt,name=required_bytes,json=requiredBytes,proto3" json:"required_bytes,omitempty"`
	// Volume MUST not be bigger than this. This field is OPTIONAL.
	// A value of 0 is equal to an unspecified field value.
	// The value of this field MUST NOT be negative.
	LimitBytes    int64 `protobuf:"varint,2,opt,name=limit_bytes,json=limitBytes,proto3" json:"limit_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CapacityRange) Reset() {
	*x = CapacityRange{}
	mi := &file_csi_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CapacityRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CapacityRange) ProtoMessage() {}

func (x *CapacityRange) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CapacityRange.ProtoReflect.Descriptor instead.
func (*CapacityRange) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{11}
}

func (x *CapacityRange) GetRequiredBytes() int64 {
	if x != nil {
		return x.RequiredBytes
	}
	return 0
}

func (x *CapacityRange) GetLimitBytes() int64 {
	if x != nil {
		return x.LimitBytes
	}
	return 0
}

// Information about a specific volume.
type Volume struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The capacity of the volume in bytes. This field is OPTIONAL. If not
	// set (value of 0), it indicates that the capacity of the volume is
	// unknown (e.g., NFS share).
	// The value of this field MUST NOT be negative.
	CapacityBytes int64 `protobuf:"varint,1,opt,name=capacity_bytes,json=capacityBytes,proto3" json:"capacity_bytes,omitempty"`
	// The identifier for this volume, generated by the plugin.
	// This field is REQUIRED.
	// This field MUST contain enough information to uniquely identify
	// this specific volume vs all other volumes supported by this plugin.
	// This field SHALL be used by the CO in subsequent calls to refer to
	// this volume.
	// The SP is NOT responsible for global uniqueness of volume_id across
	// multiple SPs.
	VolumeId string `protobuf:"bytes,2,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Opaque static properties of the volume. SP MAY use this field to
	// ensure subsequent volume validation and publishing calls have
	// contextual information.
	// The contents of this field SHALL be opaque to a CO.
	// The contents of this field SHALL NOT be mutable.
	// The contents of this field SHALL be safe for the CO to cache.
	// The contents of this field SHOULD NOT contain sensitive
	// information.
	// The contents of this field SHOULD NOT be used for uniquely
	// identifying a volume. The `volume_id` alone SHOULD be sufficient to
	// identify the volume.
	// A volume uniquely identified by `volume_id` SHALL always report the
	// same volume_context.
	// This field is OPTIONAL and when present MUST be passed to volume
	// validation and publishing calls.
	VolumeContext map[string]string `protobuf:"bytes,3,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If specified, indicates that the volume is not empty and is
	// pre-populated with data from the specified source.
	// This field is OPTIONAL.
	ContentSource *VolumeContentSource `protobuf:"bytes,4,opt,name=content_source,json=contentSource,proto3" json:"content_source,omitempty"`
	// Specifies where (regions, zones, racks, etc.) the provisioned
	// volume is accessible from.
	// A plugin that returns this field MUST also set the
	// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
	// An SP MAY specify multiple topologies to indicate the volume is
	// accessible from multiple locations.
	// COs MAY use this information along with the topology information
	// returned by NodeGetInfo to ensure that a given volume is accessible
	// from a given node when scheduling workloads.
	// This field is OPTIONAL. If it is not specified, the CO MAY assume
	// the volume is equally accessible from all nodes in the cluster and
	// MAY schedule workloads referencing the volume on any available
	// node.
	//
	// Example 1:
	//
	//	accessible_topology = {"region": "R1", "zone": "Z2"}
	//
	// Indicates a volume accessible only from the "region" "R1" and the
	// "zone" "Z2".
	//
	// Example 2:
	//
	//	accessible_topology =
	//	  {"region": "R1", "zone": "Z2"},
	//	  {"region": "R1", "zone": "Z3"}
	//
	// Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
	// in the "region" "R1".
	AccessibleTopology []*Topology `protobuf:"bytes,5,rep,name=accessible_topology,json=accessibleTopology,proto3" json:"accessible_topology,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Volume) Reset() {
	*x = Volume{}
	mi := &file_csi_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Volume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Volume) ProtoMessage() {}

func (x *Volume) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Volume.ProtoReflect.Descriptor instead.
func (*Volume) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{12}
}

func (x *Volume) GetCapacityBytes() int64 {
	if x != nil {
		return x.CapacityBytes
	}
	return 0
}

func (x *Volume) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *Volume) GetVolumeContext() map[string]string {
	if x != nil {
		return x.VolumeContext
	}
	return nil
}

func (x *Volume) GetContentSource() *VolumeContentSource {
	if x != nil {
		return x.ContentSource
	}
	return nil
}

func (x *Volume) GetAccessibleTopology() []*Topology {
	if x != nil {
		return x.AccessibleTopology
	}
	return nil
}

type TopologyRequirement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies the list of topologies the provisioned volume MUST be
	// accessible from.
	// This field is OPTIONAL. If TopologyRequirement is specified either
	// requisite or preferred or both MUST be specified.
	//
	// If requisite is specified, the provisioned volume MUST be
	// accessible from at least one of the requisite topologies.
	//
	// Given
	//
	//	x = number of topologies provisioned volume is accessible from
	//	n = number of requisite topologies
	//
	// The CO MUST ensure n >= 1. The SP MUST ensure x >= 1
	// If x==n, then the SP MUST make the provisioned volume available to
	// all topologies from the list of requisite topologies. If it is
	// unable to do so, the SP MUST fail the CreateVolume call.
	// For example, if a volume should be accessible from a single zone,
	// and requisite =
	//
	//	{"region": "R1", "zone": "Z2"}
	//
	// then the provisioned volume MUST be accessible from the "region"
	// "R1" and the "zone" "Z2".
	// Similarly, if a volume should be accessible from two zones, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the provisioned volume MUST be accessible from the "region"
	// "R1" and both "zone" "Z2" and "zone" "Z3".
	//
	// If x<n, then the SP SHALL choose x unique topologies from the list
	// of requisite topologies. If it is unable to do so, the SP MUST fail
	// the CreateVolume call.
	// For example, if a volume should be accessible from a single zone,
	// and requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the SP may choose to make the provisioned volume available in
	// either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
	// Similarly, if a volume should be accessible from two zones, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"},
	//	{"region": "R1", "zone": "Z4"}
	//
	// then the provisioned volume MUST be accessible from any combination
	// of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
	//
	//	"R1/Z4", or "R1/Z3" and "R1/Z4".
	//
	// If x>n, then the SP MUST make the provisioned volume available from
	// all topologies from the list of requisite topologies and MAY choose
	// the remaining x-n unique topologies from the list of all possible
	// topologies. If it is unable to do so, the SP MUST fail the
	// CreateVolume call.
	// For example, if a volume should be accessible from two zones, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"}
	//
	// then the provisioned volume MUST be accessible from the "region"
	// "R1" and the "zone" "Z2" and the SP may select the second zone
	// independently, e.g. "R1/Z4".
	Requisite []*Topology `protobuf:"bytes,1,rep,name=requisite,proto3" json:"requisite,omitempty"`
	// Specifies the list of topologies the CO would prefer the volume to
	// be provisioned in.
	//
	// This field is OPTIONAL. If TopologyRequirement is specified either
	// requisite or preferred or both MUST be specified.
	//
	// An SP MUST attempt to make the provisioned volume available using
	// the preferred topologies in order from first to last.
	//
	// If requisite is specified, all topologies in preferred list MUST
	// also be present in the list of requisite topologies.
	//
	// If the SP is unable to to make the provisioned volume available
	// from any of the preferred topologies, the SP MAY choose a topology
	// from the list of requisite topologies.
	// If the list of requisite topologies is not specified, then the SP
	// MAY choose from the list of all possible topologies.
	// If the list of requisite topologies is specified and the SP is
	// unable to to make the provisioned volume available from any of the
	// requisite topologies it MUST fail the CreateVolume call.
	//
	// Example 1:
	// Given a volume should be accessible from a single zone, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// preferred =
	//
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the SP SHOULD first attempt to make the provisioned volume
	// available from "zone" "Z3" in the "region" "R1" and fall back to
	// "zone" "Z2" in the "region" "R1" if that is not possible.
	//
	// Example 2:
	// Given a volume should be accessible from a single zone, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"},
	//	{"region": "R1", "zone": "Z4"},
	//	{"region": "R1", "zone": "Z5"}
	//
	// preferred =
	//
	//	{"region": "R1", "zone": "Z4"},
	//	{"region": "R1", "zone": "Z2"}
	//
	// then the SP SHOULD first attempt to make the provisioned volume
	// accessible from "zone" "Z4" in the "region" "R1" and fall back to
	// "zone" "Z2" in the "region" "R1" if that is not possible. If that
	// is not possible, the SP may choose between either the "zone"
	// "Z3" or "Z5" in the "region" "R1".
	//
	// Example 3:
	// Given a volume should be accessible from TWO zones (because an
	// opaque parameter in CreateVolumeRequest, for example, specifies
	// the volume is accessible from two zones, aka synchronously
	// replicated), and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"},
	//	{"region": "R1", "zone": "Z4"},
	//	{"region": "R1", "zone": "Z5"}
	//
	// preferred =
	//
	//	{"region": "R1", "zone": "Z5"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the SP SHOULD first attempt to make the provisioned volume
	// accessible from the combination of the two "zones" "Z5" and "Z3" in
	// the "region" "R1". If that's not possible, it should fall back to
	// a combination of "Z5" and other possibilities from the list of
	// requisite. If that's not possible, it should fall back  to a
	// combination of "Z3" and other possibilities from the list of
	// requisite. If that's not possible, it should fall back  to a
	// combination of other possibilities from the list of requisite.
	Preferred     []*Topology `protobuf:"bytes,2,rep,name=preferred,proto3" json:"preferred,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopologyRequirement) Reset() {
	*x = TopologyRequirement{}
	mi := &file_csi_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologyRequirement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologyRequirement) ProtoMessage() {}

func (x *TopologyRequirement) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologyRequirement.ProtoReflect.Descriptor instead.
func (*TopologyRequirement) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{13}
}

func (x *TopologyRequirement) GetRequisite() []*Topology {
	if x != nil {
		return x.Requisite
	}
	return nil
}

func (x *TopologyRequirement) GetPreferred() []*Topology {
	if x != nil {
		return x.Preferred
	}
	return nil
}

// Topology is a map of topological domains to topological segments.
// A topological domain is a sub-division of a cluster, like "region",
// "zone", "rack", etc.
// A topological segment is a specific instance of a topological domain,
// like "zone3", "rack3", etc.
// For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
// Valid keys have two segments: an OPTIONAL prefix and name, separated
// by a slash (/), for example: "com.company.example/zone".
// The key name segment is REQUIRED. The prefix is OPTIONAL.
// The key name MUST be 63 characters or less, begin and end with an
// alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-),
// underscores (_), dots (.), or alphanumerics in between, for example
// "zone".
// The key prefix MUST be 63 characters or less, begin and end with a
// lower-case alphanumeric character ([a-z0-9]), contain only
// dashes (-), dots (.), or lower-case alphanumerics in between, and
// follow domain name notation format
// (https://tools.ietf.org/html/rfc1035#section-2.3.1).
// The key prefix SHOULD include the plugin's host company name and/or
// the plugin name, to minimize the possibility of collisions with keys
// from other plugins.
// If a key prefix is specified, it MUST be identical across all
// topology keys returned by the SP (across all RPCs).
// Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
// MUST not both exist.
// Each value (topological segment) MUST contain 1 or more strings.
// Each string MUST be 63 characters or less and begin and end with an
// alphanumeric character with '-', '_', '.', or alphanumerics in
// between.
type Topology struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Segments      map[string]string      `protobuf:"bytes,1,rep,name=segments,proto3" json:"segments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Topology) Reset() {
	*x = Topology{}
	mi := &file_csi_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Topology) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Topology) ProtoMessage() {}

func (x *Topology) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Topology.ProtoReflect.Descriptor instead.
func (*Topology) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{14}
}

func (x *Topology) GetSegments() map[string]string {
	if x != nil {
		return x.Segments
	}
	return nil
}

type DeleteVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume to be deprovisioned.
	// This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Secrets required by plugin to complete volume deletion request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,2,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteVolumeRequest) Reset() {
	*x = DeleteVolumeRequest{}
	mi := &file_csi_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteVolumeRequest) ProtoMessage() {}

func (x *DeleteVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteVolumeRequest.ProtoReflect.Descriptor instead.
func (*DeleteVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{15}
}

func (x *DeleteVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *DeleteVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type DeleteVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteVolumeResponse) Reset() {
	*x = DeleteVolumeResponse{}
	mi := &file_csi_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteVolumeResponse) ProtoMessage() {}

func (x *DeleteVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteVolumeResponse.ProtoReflect.Descriptor instead.
func (*DeleteVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{16}
}

type ControllerPublishVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume to be used on a node.
	// This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The ID of the node. This field is REQUIRED. The CO SHALL set this
	// field to match the node ID returned by `NodeGetInfo`.
	NodeId string `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Volume capability describing how the CO intends to use this volume.
	// SP MUST ensure the CO can use the published volume as described.
	// Otherwise SP MUST return the appropriate gRPC error code.
	// This is a REQUIRED field.
	VolumeCapability *VolumeCapability `protobuf:"bytes,3,opt,name=volume_capability,json=volumeCapability,proto3" json:"volume_capability,omitempty"`
	// Indicates SP MUST publish the volume in readonly mode.
	// CO MUST set this field to false if SP does not have the
	// PUBLISH_READONLY controller capability.
	// This is a REQUIRED field.
	Readonly bool `protobuf:"varint,4,opt,name=readonly,proto3" json:"readonly,omitempty"`
	// Secrets required by plugin to complete controller publish volume
	// request. This field is OPTIONAL. Refer to the
	// `Secrets Requirements` section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Volume context as returned by SP in
	// CreateVolumeResponse.Volume.volume_context.
	// This field is OPTIONAL and MUST match the volume_context of the
	// volume identified by `volume_id`.
	VolumeContext map[string]string `protobuf:"bytes,6,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerPublishVolumeRequest) Reset() {
	*x = ControllerPublishVolumeRequest{}
	mi := &file_csi_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerPublishVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerPublishVolumeRequest) ProtoMessage() {}

func (x *ControllerPublishVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerPublishVolumeRequest.ProtoReflect.Descriptor instead.
func (*ControllerPublishVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{17}
}

func (x *ControllerPublishVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *ControllerPublishVolumeRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ControllerPublishVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if x != nil {
		return x.VolumeCapability
	}
	return nil
}

func (x *ControllerPublishVolumeRequest) GetReadonly() bool {
	if x != nil {
		return x.Readonly
	}
	return false
}

func (x *ControllerPublishVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *ControllerPublishVolumeRequest) GetVolumeContext() map[string]string {
	if x != nil {
		return x.VolumeContext
	}
	return nil
}

type ControllerPublishVolumeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Opaque static publish properties of the volume. SP MAY use this
	// field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
	// calls calls have contextual information.
	// The contents of this field SHALL be opaque to a CO.
	// The contents of this field SHALL NOT be mutable.
	// The contents of this field SHALL be safe for the CO to cache.
	// The contents of this field SHOULD NOT contain sensitive
	// information.
	// The contents of this field SHOULD NOT be used for uniquely
	// identifying a volume. The `volume_id` alone SHOULD be sufficient to
	// identify the volume.
	// This field is OPTIONAL and when present MUST be passed to
	// subsequent `NodeStageVolume` or `NodePublishVolume` calls
	PublishContext map[string]string `protobuf:"bytes,1,rep,name=publish_context,json=publishContext,proto3" json:"publish_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ControllerPublishVolumeResponse) Reset() {
	*x = ControllerPublishVolumeResponse{}
	mi := &file_csi_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerPublishVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerPublishVolumeResponse) ProtoMessage() {}

func (x *ControllerPublishVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerPublishVolumeResponse.ProtoReflect.Descriptor instead.
func (*ControllerPublishVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{18}
}

func (x *ControllerPublishVolumeResponse) GetPublishContext() map[string]string {
	if x != nil {
		return x.PublishContext
	}
	return nil
}

type ControllerUnpublishVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The ID of the node. This field is OPTIONAL. The CO SHOULD set this
	// field to match the node ID returned by `NodeGetInfo` or leave it
	// unset. If the value is set, the SP MUST unpublish the volume from
	// the specified node. If the value is unset, the SP MUST unpublish
	// the volume from all nodes it is published to.
	NodeId string `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Secrets required by plugin to complete controller unpublish volume
	// request. This SHOULD be the same secrets passed to the
	// ControllerPublishVolume call for the specified volume.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerUnpublishVolumeRequest) Reset() {
	*x = ControllerUnpublishVolumeRequest{}
	mi := &file_csi_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerUnpublishVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerUnpublishVolumeRequest) ProtoMessage() {}

func (x *ControllerUnpublishVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerUnpublishVolumeRequest.ProtoReflect.Descriptor instead.
func (*ControllerUnpublishVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{19}
}

func (x *ControllerUnpublishVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *ControllerUnpublishVolumeRequest) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *ControllerUnpublishVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type ControllerUnpublishVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerUnpublishVolumeResponse) Reset() {
	*x = ControllerUnpublishVolumeResponse{}
	mi := &file_csi_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerUnpublishVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerUnpublishVolumeResponse) ProtoMessage() {}

func (x *ControllerUnpublishVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerUnpublishVolumeResponse.ProtoReflect.Descriptor instead.
func (*ControllerUnpublishVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{20}
}

type ValidateVolumeCapabilitiesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume to check. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Volume context as returned by SP in
	// CreateVolumeResponse.Volume.volume_context.
	// This field is OPTIONAL and MUST match the volume_context of the
	// volume identified by `volume_id`.
	VolumeContext map[string]string `protobuf:"bytes,2,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The capabilities that the CO wants to check for the volume. This
	// call SHALL return "confirmed" only if all the volume capabilities
	// specified below are supported. This field is REQUIRED.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,3,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// See CreateVolumeRequest.parameters.
	// This field is OPTIONAL.
	Parameters map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Secrets required by plugin to complete volume validation request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// See CreateVolumeRequest.mutable_parameters.
	// This field is OPTIONAL.
	MutableParameters map[string]string `protobuf:"bytes,6,rep,name=mutable_parameters,json=mutableParameters,proto3" json:"mutable_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ValidateVolumeCapabilitiesRequest) Reset() {
	*x = ValidateVolumeCapabilitiesRequest{}
	mi := &file_csi_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateVolumeCapabilitiesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateVolumeCapabilitiesRequest) ProtoMessage() {}

func (x *ValidateVolumeCapabilitiesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateVolumeCapabilitiesRequest.ProtoReflect.Descriptor instead.
func (*ValidateVolumeCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{21}
}

func (x *ValidateVolumeCapabilitiesRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *ValidateVolumeCapabilitiesRequest) GetVolumeContext() map[string]string {
	if x != nil {
		return x.VolumeContext
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesRequest) GetVolumeCapabilities() []*VolumeCapability {
	if x != nil {
		return x.VolumeCapabilities
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesRequest) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesRequest) GetMutableParameters() map[string]string {
	if x != nil {
		return x.MutableParameters
	}
	return nil
}

type ValidateVolumeCapabilitiesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Confirmed indicates to the CO the set of capabilities that the
	// plugin has validated. This field SHALL only be set to a non-empty
	// value for successful validation responses.
	// For successful validation responses, the CO SHALL compare the
	// fields of this message to the originally requested capabilities in
	// order to guard against an older plugin reporting "valid" for newer
	// capability fields that it does not yet understand.
	// This field is OPTIONAL.
	Confirmed *ValidateVolumeCapabilitiesResponse_Confirmed `protobuf:"bytes,1,opt,name=confirmed,proto3" json:"confirmed,omitempty"`
	// Message to the CO if `confirmed` above is empty. This field is
	// OPTIONAL.
	// An empty string is equal to an unspecified field value.
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateVolumeCapabilitiesResponse) Reset() {
	*x = ValidateVolumeCapabilitiesResponse{}
	mi := &file_csi_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateVolumeCapabilitiesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateVolumeCapabilitiesResponse) ProtoMessage() {}

func (x *ValidateVolumeCapabilitiesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateVolumeCapabilitiesResponse.ProtoReflect.Descriptor instead.
func (*ValidateVolumeCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{22}
}

func (x *ValidateVolumeCapabilitiesResponse) GetConfirmed() *ValidateVolumeCapabilitiesResponse_Confirmed {
	if x != nil {
		return x.Confirmed
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type ListVolumesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If specified (non-zero value), the Plugin MUST NOT return more
	// entries than this number in the response. If the actual number of
	// entries is more than this number, the Plugin MUST set `next_token`
	// in the response which can be used to get the next page of entries
	// in the subsequent `ListVolumes` call. This field is OPTIONAL. If
	// not specified (zero value), it means there is no restriction on the
	// number of entries that can be returned.
	// The value of this field MUST NOT be negative.
	MaxEntries int32 `protobuf:"varint,1,opt,name=max_entries,json=maxEntries,proto3" json:"max_entries,omitempty"`
	// A token to specify where to start paginating. Set this field to
	// `next_token` returned by a previous `ListVolumes` call to get the
	// next page of entries. This field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	StartingToken string `protobuf:"bytes,2,opt,name=starting_token,json=startingToken,proto3" json:"starting_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListVolumesRequest) Reset() {
	*x = ListVolumesRequest{}
	mi := &file_csi_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListVolumesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListVolumesRequest) ProtoMessage() {}

func (x *ListVolumesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListVolumesRequest.ProtoReflect.Descriptor instead.
func (*ListVolumesRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{23}
}

func (x *ListVolumesRequest) GetMaxEntries() int32 {
	if x != nil {
		return x.MaxEntries
	}
	return 0
}

func (x *ListVolumesRequest) GetStartingToken() string {
	if x != nil {
		return x.StartingToken
	}
	return ""
}

type ListVolumesResponse struct {
	state   protoimpl.MessageState       `protogen:"open.v1"`
	Entries []*ListVolumesResponse_Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	// This token allows you to get the next page of entries for
	// `ListVolumes` request. If the number of entries is larger than
	// `max_entries`, use the `next_token` as a value for the
	// `starting_token` field in the next `ListVolumes` request. This
	// field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	NextToken     string `protobuf:"bytes,2,opt,name=next_token,json=nextToken,proto3" json:"next_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListVolumesResponse) Reset() {
	*x = ListVolumesResponse{}
	mi := &file_csi_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListVolumesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListVolumesResponse) ProtoMessage() {}

func (x *ListVolumesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListVolumesResponse.ProtoReflect.Descriptor instead.
func (*ListVolumesResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{24}
}

func (x *ListVolumesResponse) GetEntries() []*ListVolumesResponse_Entry {
	if x != nil {
		return x.Entries
	}
	return nil
}

func (x *ListVolumesResponse) GetNextToken() string {
	if x != nil {
		return x.NextToken
	}
	return ""
}

type ControllerGetVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume to fetch current volume information for.
	// This field is REQUIRED.
	VolumeId      string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerGetVolumeRequest) Reset() {
	*x = ControllerGetVolumeRequest{}
	mi := &file_csi_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerGetVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerGetVolumeRequest) ProtoMessage() {}

func (x *ControllerGetVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerGetVolumeRequest.ProtoReflect.Descriptor instead.
func (*ControllerGetVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{25}
}

func (x *ControllerGetVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

type ControllerGetVolumeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is REQUIRED
	Volume *Volume `protobuf:"bytes,1,opt,name=volume,proto3" json:"volume,omitempty"`
	// This field is REQUIRED.
	Status        *ControllerGetVolumeResponse_VolumeStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerGetVolumeResponse) Reset() {
	*x = ControllerGetVolumeResponse{}
	mi := &file_csi_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerGetVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerGetVolumeResponse) ProtoMessage() {}

func (x *ControllerGetVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerGetVolumeResponse.ProtoReflect.Descriptor instead.
func (*ControllerGetVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{26}
}

func (x *ControllerGetVolumeResponse) GetVolume() *Volume {
	if x != nil {
		return x.Volume
	}
	return nil
}

func (x *ControllerGetVolumeResponse) GetStatus() *ControllerGetVolumeResponse_VolumeStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type ControllerModifyVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Contains identity information for the existing volume.
	// This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Secrets required by plugin to complete modify volume request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,2,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Plugin specific volume attributes to mutate, passed in as
	// opaque key-value pairs.
	// This field is REQUIRED. The Plugin is responsible for
	// parsing and validating these parameters. COs will treat these
	// as opaque. The CO SHOULD specify the intended values of all mutable
	// parameters it intends to modify. SPs MUST NOT modify volumes based
	// on the absence of keys, only keys that are specified should result
	// in modifications to the volume.
	MutableParameters map[string]string `protobuf:"bytes,3,rep,name=mutable_parameters,json=mutableParameters,proto3" json:"mutable_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ControllerModifyVolumeRequest) Reset() {
	*x = ControllerModifyVolumeRequest{}
	mi := &file_csi_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerModifyVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerModifyVolumeRequest) ProtoMessage() {}

func (x *ControllerModifyVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerModifyVolumeRequest.ProtoReflect.Descriptor instead.
func (*ControllerModifyVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{27}
}

func (x *ControllerModifyVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *ControllerModifyVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *ControllerModifyVolumeRequest) GetMutableParameters() map[string]string {
	if x != nil {
		return x.MutableParameters
	}
	return nil
}

type ControllerModifyVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerModifyVolumeResponse) Reset() {
	*x = ControllerModifyVolumeResponse{}
	mi := &file_csi_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerModifyVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerModifyVolumeResponse) ProtoMessage() {}

func (x *ControllerModifyVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerModifyVolumeResponse.ProtoReflect.Descriptor instead.
func (*ControllerModifyVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{28}
}

type GetCapacityRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If specified, the Plugin SHALL report the capacity of the storage
	// that can be used to provision volumes that satisfy ALL of the
	// specified `volume_capabilities`. These are the same
	// `volume_capabilities` the CO will use in `CreateVolumeRequest`.
	// This field is OPTIONAL.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,1,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// If specified, the Plugin SHALL report the capacity of the storage
	// that can be used to provision volumes with the given Plugin
	// specific `parameters`. These are the same `parameters` the CO will
	// use in `CreateVolumeRequest`. This field is OPTIONAL.
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If specified, the Plugin SHALL report the capacity of the storage
	// that can be used to provision volumes that in the specified
	// `accessible_topology`. This is the same as the
	// `accessible_topology` the CO returns in a `CreateVolumeResponse`.
	// This field is OPTIONAL. This field SHALL NOT be set unless the
	// plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
	AccessibleTopology *Topology `protobuf:"bytes,3,opt,name=accessible_topology,json=accessibleTopology,proto3" json:"accessible_topology,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GetCapacityRequest) Reset() {
	*x = GetCapacityRequest{}
	mi := &file_csi_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCapacityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCapacityRequest) ProtoMessage() {}

func (x *GetCapacityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCapacityRequest.ProtoReflect.Descriptor instead.
func (*GetCapacityRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{29}
}

func (x *GetCapacityRequest) GetVolumeCapabilities() []*VolumeCapability {
	if x != nil {
		return x.VolumeCapabilities
	}
	return nil
}

func (x *GetCapacityRequest) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *GetCapacityRequest) GetAccessibleTopology() *Topology {
	if x != nil {
		return x.AccessibleTopology
	}
	return nil
}

type GetCapacityResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The available capacity, in bytes, of the storage that can be used
	// to provision volumes. If `volume_capabilities` or `parameters` is
	// specified in the request, the Plugin SHALL take those into
	// consideration when calculating the available capacity of the
	// storage. This field is REQUIRED.
	// The value of this field MUST NOT be negative.
	AvailableCapacity int64 `protobuf:"varint,1,opt,name=available_capacity,json=availableCapacity,proto3" json:"available_capacity,omitempty"`
	// The largest size that may be used in a
	// CreateVolumeRequest.capacity_range.required_bytes field
	// to create a volume with the same parameters as those in
	// GetCapacityRequest.
	//
	// If `volume_capabilities` or `parameters` is
	// specified in the request, the Plugin SHALL take those into
	// consideration when calculating the minimum volume size of the
	// storage.
	//
	// This field is OPTIONAL. MUST NOT be negative.
	// The Plugin SHOULD provide a value for this field if it has
	// a maximum size for individual volumes and leave it unset
	// otherwise. COs MAY use it to make decision about
	// where to create volumes.
	MaximumVolumeSize *wrappers.Int64Value `protobuf:"bytes,2,opt,name=maximum_volume_size,json=maximumVolumeSize,proto3" json:"maximum_volume_size,omitempty"`
	// The smallest size that may be used in a
	// CreateVolumeRequest.capacity_range.limit_bytes field
	// to create a volume with the same parameters as those in
	// GetCapacityRequest.
	//
	// If `volume_capabilities` or `parameters` is
	// specified in the request, the Plugin SHALL take those into
	// consideration when calculating the maximum volume size of the
	// storage.
	//
	// This field is OPTIONAL. MUST NOT be negative.
	// The Plugin SHOULD provide a value for this field if it has
	// a minimum size for individual volumes and leave it unset
	// otherwise. COs MAY use it to make decision about
	// where to create volumes.
	MinimumVolumeSize *wrappers.Int64Value `protobuf:"bytes,3,opt,name=minimum_volume_size,json=minimumVolumeSize,proto3" json:"minimum_volume_size,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GetCapacityResponse) Reset() {
	*x = GetCapacityResponse{}
	mi := &file_csi_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCapacityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCapacityResponse) ProtoMessage() {}

func (x *GetCapacityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCapacityResponse.ProtoReflect.Descriptor instead.
func (*GetCapacityResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{30}
}

func (x *GetCapacityResponse) GetAvailableCapacity() int64 {
	if x != nil {
		return x.AvailableCapacity
	}
	return 0
}

func (x *GetCapacityResponse) GetMaximumVolumeSize() *wrappers.Int64Value {
	if x != nil {
		return x.MaximumVolumeSize
	}
	return nil
}

func (x *GetCapacityResponse) GetMinimumVolumeSize() *wrappers.Int64Value {
	if x != nil {
		return x.MinimumVolumeSize
	}
	return nil
}

type ControllerGetCapabilitiesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerGetCapabilitiesRequest) Reset() {
	*x = ControllerGetCapabilitiesRequest{}
	mi := &file_csi_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerGetCapabilitiesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerGetCapabilitiesRequest) ProtoMessage() {}

func (x *ControllerGetCapabilitiesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerGetCapabilitiesRequest.ProtoReflect.Descriptor instead.
func (*ControllerGetCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{31}
}

type ControllerGetCapabilitiesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// All the capabilities that the controller service supports. This
	// field is OPTIONAL.
	Capabilities  []*ControllerServiceCapability `protobuf:"bytes,1,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerGetCapabilitiesResponse) Reset() {
	*x = ControllerGetCapabilitiesResponse{}
	mi := &file_csi_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerGetCapabilitiesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerGetCapabilitiesResponse) ProtoMessage() {}

func (x *ControllerGetCapabilitiesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerGetCapabilitiesResponse.ProtoReflect.Descriptor instead.
func (*ControllerGetCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{32}
}

func (x *ControllerGetCapabilitiesResponse) GetCapabilities() []*ControllerServiceCapability {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

// Specifies a capability of the controller service.
type ControllerServiceCapability struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*ControllerServiceCapability_Rpc
	Type          isControllerServiceCapability_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerServiceCapability) Reset() {
	*x = ControllerServiceCapability{}
	mi := &file_csi_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerServiceCapability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerServiceCapability) ProtoMessage() {}

func (x *ControllerServiceCapability) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerServiceCapability.ProtoReflect.Descriptor instead.
func (*ControllerServiceCapability) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{33}
}

func (x *ControllerServiceCapability) GetType() isControllerServiceCapability_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *ControllerServiceCapability) GetRpc() *ControllerServiceCapability_RPC {
	if x != nil {
		if x, ok := x.Type.(*ControllerServiceCapability_Rpc); ok {
			return x.Rpc
		}
	}
	return nil
}

type isControllerServiceCapability_Type interface {
	isControllerServiceCapability_Type()
}

type ControllerServiceCapability_Rpc struct {
	// RPC that the controller supports.
	Rpc *ControllerServiceCapability_RPC `protobuf:"bytes,1,opt,name=rpc,proto3,oneof"`
}

func (*ControllerServiceCapability_Rpc) isControllerServiceCapability_Type() {}

type CreateSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the source volume to be snapshotted.
	// This field is REQUIRED.
	SourceVolumeId string `protobuf:"bytes,1,opt,name=source_volume_id,json=sourceVolumeId,proto3" json:"source_volume_id,omitempty"`
	// The suggested name for the snapshot. This field is REQUIRED for
	// idempotency.
	// Any Unicode string that conforms to the length limit is allowed
	// except those containing the following banned characters:
	// U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
	// (These are control characters other than commonly used whitespace.)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Secrets required by plugin to complete snapshot creation request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Plugin specific parameters passed in as opaque key-value pairs.
	// This field is OPTIONAL. The Plugin is responsible for parsing and
	// validating these parameters. COs will treat these as opaque.
	// Use cases for opaque parameters:
	//   - Specify a policy to automatically clean up the snapshot.
	//   - Specify an expiration date for the snapshot.
	//   - Specify whether the snapshot is readonly or read/write.
	//   - Specify if the snapshot should be replicated to some place.
	//   - Specify primary or secondary for replication systems that
	//     support snapshotting only on primary.
	Parameters    map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateSnapshotRequest) Reset() {
	*x = CreateSnapshotRequest{}
	mi := &file_csi_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateSnapshotRequest) ProtoMessage() {}

func (x *CreateSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateSnapshotRequest.ProtoReflect.Descriptor instead.
func (*CreateSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{34}
}

func (x *CreateSnapshotRequest) GetSourceVolumeId() string {
	if x != nil {
		return x.SourceVolumeId
	}
	return ""
}

func (x *CreateSnapshotRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateSnapshotRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *CreateSnapshotRequest) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

type CreateSnapshotResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Contains all attributes of the newly created snapshot that are
	// relevant to the CO along with information required by the Plugin
	// to uniquely identify the snapshot. This field is REQUIRED.
	Snapshot      *Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateSnapshotResponse) Reset() {
	*x = CreateSnapshotResponse{}
	mi := &file_csi_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateSnapshotResponse) ProtoMessage() {}

func (x *CreateSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateSnapshotResponse.ProtoReflect.Descriptor instead.
func (*CreateSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{35}
}

func (x *CreateSnapshotResponse) GetSnapshot() *Snapshot {
	if x != nil {
		return x.Snapshot
	}
	return nil
}

// Information about a specific snapshot.
type Snapshot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the complete size of the snapshot in bytes. The purpose of
	// this field is to give CO guidance on how much space is needed to
	// create a volume from this snapshot. The size of the volume MUST NOT
	// be less than the size of the source snapshot. This field is
	// OPTIONAL. If this field is not set, it indicates that this size is
	// unknown. The value of this field MUST NOT be negative and a size of
	// zero means it is unspecified.
	SizeBytes int64 `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// The identifier for this snapshot, generated by the plugin.
	// This field is REQUIRED.
	// This field MUST contain enough information to uniquely identify
	// this specific snapshot vs all other snapshots supported by this
	// plugin.
	// This field SHALL be used by the CO in subsequent calls to refer to
	// this snapshot.
	// The SP is NOT responsible for global uniqueness of snapshot_id
	// across multiple SPs.
	SnapshotId string `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// Identity information for the source volume. Note that creating a
	// snapshot from a snapshot is not supported here so the source has to
	// be a volume. This field is REQUIRED.
	SourceVolumeId string `protobuf:"bytes,3,opt,name=source_volume_id,json=sourceVolumeId,proto3" json:"source_volume_id,omitempty"`
	// Timestamp when the point-in-time snapshot is taken on the storage
	// system. This field is REQUIRED.
	CreationTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// Indicates if a snapshot is ready to use as a
	// `volume_content_source` in a `CreateVolumeRequest`. The default
	// value is false. This field is REQUIRED.
	ReadyToUse bool `protobuf:"varint,5,opt,name=ready_to_use,json=readyToUse,proto3" json:"ready_to_use,omitempty"`
	// The ID of the volume group snapshot that this snapshot is part of.
	// It uniquely identifies the group snapshot on the storage system.
	// This field is OPTIONAL.
	// If this snapshot is a member of a volume group snapshot, and it
	// MUST NOT be deleted as a stand alone snapshot, then the SP
	// MUST provide the ID of the volume group snapshot in this field.
	// If provided, CO MUST use this field in subsequent volume group
	// snapshot operations to indicate that this snapshot is part of the
	// specified group snapshot.
	// If not provided, CO SHALL treat the snapshot as independent,
	// and SP SHALL allow it to be deleted separately.
	// If this message is inside a VolumeGroupSnapshot message, the value
	// MUST be the same as the group_snapshot_id in that message.
	GroupSnapshotId string `protobuf:"bytes,6,opt,name=group_snapshot_id,json=groupSnapshotId,proto3" json:"group_snapshot_id,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Snapshot) Reset() {
	*x = Snapshot{}
	mi := &file_csi_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Snapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Snapshot) ProtoMessage() {}

func (x *Snapshot) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Snapshot.ProtoReflect.Descriptor instead.
func (*Snapshot) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{36}
}

func (x *Snapshot) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *Snapshot) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

func (x *Snapshot) GetSourceVolumeId() string {
	if x != nil {
		return x.SourceVolumeId
	}
	return ""
}

func (x *Snapshot) GetCreationTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreationTime
	}
	return nil
}

func (x *Snapshot) GetReadyToUse() bool {
	if x != nil {
		return x.ReadyToUse
	}
	return false
}

func (x *Snapshot) GetGroupSnapshotId() string {
	if x != nil {
		return x.GroupSnapshotId
	}
	return ""
}

type DeleteSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the snapshot to be deleted.
	// This field is REQUIRED.
	SnapshotId string `protobuf:"bytes,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// Secrets required by plugin to complete snapshot deletion request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,2,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteSnapshotRequest) Reset() {
	*x = DeleteSnapshotRequest{}
	mi := &file_csi_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteSnapshotRequest) ProtoMessage() {}

func (x *DeleteSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteSnapshotRequest.ProtoReflect.Descriptor instead.
func (*DeleteSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{37}
}

func (x *DeleteSnapshotRequest) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

func (x *DeleteSnapshotRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type DeleteSnapshotResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteSnapshotResponse) Reset() {
	*x = DeleteSnapshotResponse{}
	mi := &file_csi_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteSnapshotResponse) ProtoMessage() {}

func (x *DeleteSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteSnapshotResponse.ProtoReflect.Descriptor instead.
func (*DeleteSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{38}
}

// List all snapshots on the storage system regardless of how they were
// created.
type ListSnapshotsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If specified (non-zero value), the Plugin MUST NOT return more
	// entries than this number in the response. If the actual number of
	// entries is more than this number, the Plugin MUST set `next_token`
	// in the response which can be used to get the next page of entries
	// in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
	// not specified (zero value), it means there is no restriction on the
	// number of entries that can be returned.
	// The value of this field MUST NOT be negative.
	MaxEntries int32 `protobuf:"varint,1,opt,name=max_entries,json=maxEntries,proto3" json:"max_entries,omitempty"`
	// A token to specify where to start paginating. Set this field to
	// `next_token` returned by a previous `ListSnapshots` call to get the
	// next page of entries. This field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	StartingToken string `protobuf:"bytes,2,opt,name=starting_token,json=startingToken,proto3" json:"starting_token,omitempty"`
	// Identity information for the source volume. This field is OPTIONAL.
	// It can be used to list snapshots by volume.
	SourceVolumeId string `protobuf:"bytes,3,opt,name=source_volume_id,json=sourceVolumeId,proto3" json:"source_volume_id,omitempty"`
	// Identity information for a specific snapshot. This field is
	// OPTIONAL. It can be used to list only a specific snapshot.
	// ListSnapshots will return with current snapshot information
	// and will not block if the snapshot is being processed after
	// it is cut.
	SnapshotId string `protobuf:"bytes,4,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// Secrets required by plugin to complete ListSnapshot request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSnapshotsRequest) Reset() {
	*x = ListSnapshotsRequest{}
	mi := &file_csi_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSnapshotsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSnapshotsRequest) ProtoMessage() {}

func (x *ListSnapshotsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSnapshotsRequest.ProtoReflect.Descriptor instead.
func (*ListSnapshotsRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{39}
}

func (x *ListSnapshotsRequest) GetMaxEntries() int32 {
	if x != nil {
		return x.MaxEntries
	}
	return 0
}

func (x *ListSnapshotsRequest) GetStartingToken() string {
	if x != nil {
		return x.StartingToken
	}
	return ""
}

func (x *ListSnapshotsRequest) GetSourceVolumeId() string {
	if x != nil {
		return x.SourceVolumeId
	}
	return ""
}

func (x *ListSnapshotsRequest) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

func (x *ListSnapshotsRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type ListSnapshotsResponse struct {
	state   protoimpl.MessageState         `protogen:"open.v1"`
	Entries []*ListSnapshotsResponse_Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	// This token allows you to get the next page of entries for
	// `ListSnapshots` request. If the number of entries is larger than
	// `max_entries`, use the `next_token` as a value for the
	// `starting_token` field in the next `ListSnapshots` request. This
	// field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	NextToken     string `protobuf:"bytes,2,opt,name=next_token,json=nextToken,proto3" json:"next_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSnapshotsResponse) Reset() {
	*x = ListSnapshotsResponse{}
	mi := &file_csi_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSnapshotsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSnapshotsResponse) ProtoMessage() {}

func (x *ListSnapshotsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSnapshotsResponse.ProtoReflect.Descriptor instead.
func (*ListSnapshotsResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{40}
}

func (x *ListSnapshotsResponse) GetEntries() []*ListSnapshotsResponse_Entry {
	if x != nil {
		return x.Entries
	}
	return nil
}

func (x *ListSnapshotsResponse) GetNextToken() string {
	if x != nil {
		return x.NextToken
	}
	return ""
}

type GetSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the snapshot to fetch current snapshot information for.
	// This field is REQUIRED.
	SnapshotId string `protobuf:"bytes,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// Secrets required by plugin to complete GetSnapshot request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,2,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSnapshotRequest) Reset() {
	*x = GetSnapshotRequest{}
	mi := &file_csi_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSnapshotRequest) ProtoMessage() {}

func (x *GetSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSnapshotRequest.ProtoReflect.Descriptor instead.
func (*GetSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{41}
}

func (x *GetSnapshotRequest) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

func (x *GetSnapshotRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type GetSnapshotResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is REQUIRED
	Snapshot      *Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSnapshotResponse) Reset() {
	*x = GetSnapshotResponse{}
	mi := &file_csi_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSnapshotResponse) ProtoMessage() {}

func (x *GetSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSnapshotResponse.ProtoReflect.Descriptor instead.
func (*GetSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{42}
}

func (x *GetSnapshotResponse) GetSnapshot() *Snapshot {
	if x != nil {
		return x.Snapshot
	}
	return nil
}

type ControllerExpandVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume to expand. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// This allows CO to specify the capacity requirements of the volume
	// after expansion. This field is REQUIRED.
	CapacityRange *CapacityRange `protobuf:"bytes,2,opt,name=capacity_range,json=capacityRange,proto3" json:"capacity_range,omitempty"`
	// Secrets required by the plugin for expanding the volume.
	// This field is OPTIONAL.
	Secrets map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Volume capability describing how the CO intends to use this volume.
	// This allows SP to determine if volume is being used as a block
	// device or mounted file system. For example - if volume is
	// being used as a block device - the SP MAY set
	// node_expansion_required to false in ControllerExpandVolumeResponse
	// to skip invocation of NodeExpandVolume on the node by the CO.
	// This is an OPTIONAL field.
	VolumeCapability *VolumeCapability `protobuf:"bytes,4,opt,name=volume_capability,json=volumeCapability,proto3" json:"volume_capability,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ControllerExpandVolumeRequest) Reset() {
	*x = ControllerExpandVolumeRequest{}
	mi := &file_csi_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerExpandVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerExpandVolumeRequest) ProtoMessage() {}

func (x *ControllerExpandVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerExpandVolumeRequest.ProtoReflect.Descriptor instead.
func (*ControllerExpandVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{43}
}

func (x *ControllerExpandVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *ControllerExpandVolumeRequest) GetCapacityRange() *CapacityRange {
	if x != nil {
		return x.CapacityRange
	}
	return nil
}

func (x *ControllerExpandVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *ControllerExpandVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if x != nil {
		return x.VolumeCapability
	}
	return nil
}

type ControllerExpandVolumeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Capacity of volume after expansion. This field is REQUIRED.
	CapacityBytes int64 `protobuf:"varint,1,opt,name=capacity_bytes,json=capacityBytes,proto3" json:"capacity_bytes,omitempty"`
	// Whether node expansion is required for the volume. When true
	// the CO MUST make NodeExpandVolume RPC call on the node. This field
	// is REQUIRED.
	NodeExpansionRequired bool `protobuf:"varint,2,opt,name=node_expansion_required,json=nodeExpansionRequired,proto3" json:"node_expansion_required,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ControllerExpandVolumeResponse) Reset() {
	*x = ControllerExpandVolumeResponse{}
	mi := &file_csi_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerExpandVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerExpandVolumeResponse) ProtoMessage() {}

func (x *ControllerExpandVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerExpandVolumeResponse.ProtoReflect.Descriptor instead.
func (*ControllerExpandVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{44}
}

func (x *ControllerExpandVolumeResponse) GetCapacityBytes() int64 {
	if x != nil {
		return x.CapacityBytes
	}
	return 0
}

func (x *ControllerExpandVolumeResponse) GetNodeExpansionRequired() bool {
	if x != nil {
		return x.NodeExpansionRequired
	}
	return false
}

type NodeStageVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume to publish. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The CO SHALL set this field to the value returned by
	// `ControllerPublishVolume` if the corresponding Controller Plugin
	// has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
	// left unset if the corresponding Controller Plugin does not have
	// this capability. This is an OPTIONAL field.
	PublishContext map[string]string `protobuf:"bytes,2,rep,name=publish_context,json=publishContext,proto3" json:"publish_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The path to which the volume MAY be staged. It MUST be an
	// absolute path in the root filesystem of the process serving this
	// request, and MUST be a directory. The CO SHALL ensure that there
	// is only one `staging_target_path` per volume. The CO SHALL ensure
	// that the path is directory and that the process serving the
	// request has `read` and `write` permission to that directory. The
	// CO SHALL be responsible for creating the directory if it does not
	// exist.
	// This is a REQUIRED field.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	StagingTargetPath string `protobuf:"bytes,3,opt,name=staging_target_path,json=stagingTargetPath,proto3" json:"staging_target_path,omitempty"`
	// Volume capability describing how the CO intends to use this volume.
	// SP MUST ensure the CO can use the staged volume as described.
	// Otherwise SP MUST return the appropriate gRPC error code.
	// This is a REQUIRED field.
	VolumeCapability *VolumeCapability `protobuf:"bytes,4,opt,name=volume_capability,json=volumeCapability,proto3" json:"volume_capability,omitempty"`
	// Secrets required by plugin to complete node stage volume request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Volume context as returned by SP in
	// CreateVolumeResponse.Volume.volume_context.
	// This field is OPTIONAL and MUST match the volume_context of the
	// volume identified by `volume_id`.
	VolumeContext map[string]string `protobuf:"bytes,6,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeStageVolumeRequest) Reset() {
	*x = NodeStageVolumeRequest{}
	mi := &file_csi_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeStageVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeStageVolumeRequest) ProtoMessage() {}

func (x *NodeStageVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeStageVolumeRequest.ProtoReflect.Descriptor instead.
func (*NodeStageVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{45}
}

func (x *NodeStageVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *NodeStageVolumeRequest) GetPublishContext() map[string]string {
	if x != nil {
		return x.PublishContext
	}
	return nil
}

func (x *NodeStageVolumeRequest) GetStagingTargetPath() string {
	if x != nil {
		return x.StagingTargetPath
	}
	return ""
}

func (x *NodeStageVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if x != nil {
		return x.VolumeCapability
	}
	return nil
}

func (x *NodeStageVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *NodeStageVolumeRequest) GetVolumeContext() map[string]string {
	if x != nil {
		return x.VolumeContext
	}
	return nil
}

type NodeStageVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeStageVolumeResponse) Reset() {
	*x = NodeStageVolumeResponse{}
	mi := &file_csi_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeStageVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeStageVolumeResponse) ProtoMessage() {}

func (x *NodeStageVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeStageVolumeResponse.ProtoReflect.Descriptor instead.
func (*NodeStageVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{46}
}

type NodeUnstageVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The path at which the volume was staged. It MUST be an absolute
	// path in the root filesystem of the process serving this request.
	// This is a REQUIRED field.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	StagingTargetPath string `protobuf:"bytes,2,opt,name=staging_target_path,json=stagingTargetPath,proto3" json:"staging_target_path,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *NodeUnstageVolumeRequest) Reset() {
	*x = NodeUnstageVolumeRequest{}
	mi := &file_csi_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeUnstageVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeUnstageVolumeRequest) ProtoMessage() {}

func (x *NodeUnstageVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeUnstageVolumeRequest.ProtoReflect.Descriptor instead.
func (*NodeUnstageVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{47}
}

func (x *NodeUnstageVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *NodeUnstageVolumeRequest) GetStagingTargetPath() string {
	if x != nil {
		return x.StagingTargetPath
	}
	return ""
}

type NodeUnstageVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeUnstageVolumeResponse) Reset() {
	*x = NodeUnstageVolumeResponse{}
	mi := &file_csi_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeUnstageVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeUnstageVolumeResponse) ProtoMessage() {}

func (x *NodeUnstageVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeUnstageVolumeResponse.ProtoReflect.Descriptor instead.
func (*NodeUnstageVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{48}
}

type NodePublishVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume to publish. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The CO SHALL set this field to the value returned by
	// `ControllerPublishVolume` if the corresponding Controller Plugin
	// has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
	// left unset if the corresponding Controller Plugin does not have
	// this capability. This is an OPTIONAL field.
	PublishContext map[string]string `protobuf:"bytes,2,rep,name=publish_context,json=publishContext,proto3" json:"publish_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The path to which the volume was staged by `NodeStageVolume`.
	// It MUST be an absolute path in the root filesystem of the process
	// serving this request.
	// It MUST be set if the Node Plugin implements the
	// `STAGE_UNSTAGE_VOLUME` node capability.
	// This is an OPTIONAL field.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	StagingTargetPath string `protobuf:"bytes,3,opt,name=staging_target_path,json=stagingTargetPath,proto3" json:"staging_target_path,omitempty"`
	// The path to which the volume will be published. It MUST be an
	// absolute path in the root filesystem of the process serving this
	// request. The CO SHALL ensure uniqueness of target_path per volume.
	// The CO SHALL ensure that the parent directory of this path exists
	// and that the process serving the request has `read` and `write`
	// permissions to that parent directory.
	// For volumes with an access type of block, the SP SHALL place the
	// block device at target_path.
	// For volumes with an access type of mount, the SP SHALL place the
	// mounted directory at target_path.
	// Creation of target_path is the responsibility of the SP.
	// This is a REQUIRED field.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	TargetPath string `protobuf:"bytes,4,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// Volume capability describing how the CO intends to use this volume.
	// SP MUST ensure the CO can use the published volume as described.
	// Otherwise SP MUST return the appropriate gRPC error code.
	// This is a REQUIRED field.
	VolumeCapability *VolumeCapability `protobuf:"bytes,5,opt,name=volume_capability,json=volumeCapability,proto3" json:"volume_capability,omitempty"`
	// Indicates SP MUST publish the volume in readonly mode.
	// This field is REQUIRED.
	Readonly bool `protobuf:"varint,6,opt,name=readonly,proto3" json:"readonly,omitempty"`
	// Secrets required by plugin to complete node publish volume request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,7,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Volume context as returned by SP in
	// CreateVolumeResponse.Volume.volume_context.
	// This field is OPTIONAL and MUST match the volume_context of the
	// volume identified by `volume_id`.
	VolumeContext map[string]string `protobuf:"bytes,8,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodePublishVolumeRequest) Reset() {
	*x = NodePublishVolumeRequest{}
	mi := &file_csi_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodePublishVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodePublishVolumeRequest) ProtoMessage() {}

func (x *NodePublishVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodePublishVolumeRequest.ProtoReflect.Descriptor instead.
func (*NodePublishVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{49}
}

func (x *NodePublishVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *NodePublishVolumeRequest) GetPublishContext() map[string]string {
	if x != nil {
		return x.PublishContext
	}
	return nil
}

func (x *NodePublishVolumeRequest) GetStagingTargetPath() string {
	if x != nil {
		return x.StagingTargetPath
	}
	return ""
}

func (x *NodePublishVolumeRequest) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

func (x *NodePublishVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if x != nil {
		return x.VolumeCapability
	}
	return nil
}

func (x *NodePublishVolumeRequest) GetReadonly() bool {
	if x != nil {
		return x.Readonly
	}
	return false
}

func (x *NodePublishVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *NodePublishVolumeRequest) GetVolumeContext() map[string]string {
	if x != nil {
		return x.VolumeContext
	}
	return nil
}

type NodePublishVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodePublishVolumeResponse) Reset() {
	*x = NodePublishVolumeResponse{}
	mi := &file_csi_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodePublishVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodePublishVolumeResponse) ProtoMessage() {}

func (x *NodePublishVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodePublishVolumeResponse.ProtoReflect.Descriptor instead.
func (*NodePublishVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{50}
}

type NodeUnpublishVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The path at which the volume was published. It MUST be an absolute
	// path in the root filesystem of the process serving this request.
	// The SP MUST delete the file or directory it created at this path.
	// This is a REQUIRED field.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	TargetPath    string `protobuf:"bytes,2,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeUnpublishVolumeRequest) Reset() {
	*x = NodeUnpublishVolumeRequest{}
	mi := &file_csi_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeUnpublishVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeUnpublishVolumeRequest) ProtoMessage() {}

func (x *NodeUnpublishVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeUnpublishVolumeRequest.ProtoReflect.Descriptor instead.
func (*NodeUnpublishVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{51}
}

func (x *NodeUnpublishVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *NodeUnpublishVolumeRequest) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

type NodeUnpublishVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeUnpublishVolumeResponse) Reset() {
	*x = NodeUnpublishVolumeResponse{}
	mi := &file_csi_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeUnpublishVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeUnpublishVolumeResponse) ProtoMessage() {}

func (x *NodeUnpublishVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeUnpublishVolumeResponse.ProtoReflect.Descriptor instead.
func (*NodeUnpublishVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{52}
}

type NodeGetVolumeStatsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// It can be any valid path where volume was previously
	// staged or published.
	// It MUST be an absolute path in the root filesystem of
	// the process serving this request.
	// This is a REQUIRED field.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	VolumePath string `protobuf:"bytes,2,opt,name=volume_path,json=volumePath,proto3" json:"volume_path,omitempty"`
	// The path where the volume is staged, if the plugin has the
	// STAGE_UNSTAGE_VOLUME capability, otherwise empty.
	// If not empty, it MUST be an absolute path in the root
	// filesystem of the process serving this request.
	// This field is OPTIONAL.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	StagingTargetPath string `protobuf:"bytes,3,opt,name=staging_target_path,json=stagingTargetPath,proto3" json:"staging_target_path,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *NodeGetVolumeStatsRequest) Reset() {
	*x = NodeGetVolumeStatsRequest{}
	mi := &file_csi_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGetVolumeStatsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGetVolumeStatsRequest) ProtoMessage() {}

func (x *NodeGetVolumeStatsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGetVolumeStatsRequest.ProtoReflect.Descriptor instead.
func (*NodeGetVolumeStatsRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{53}
}

func (x *NodeGetVolumeStatsRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *NodeGetVolumeStatsRequest) GetVolumePath() string {
	if x != nil {
		return x.VolumePath
	}
	return ""
}

func (x *NodeGetVolumeStatsRequest) GetStagingTargetPath() string {
	if x != nil {
		return x.StagingTargetPath
	}
	return ""
}

type NodeGetVolumeStatsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is OPTIONAL.
	Usage []*VolumeUsage `protobuf:"bytes,1,rep,name=usage,proto3" json:"usage,omitempty"`
	// Information about the current condition of the volume.
	// This field is OPTIONAL.
	// This field MUST be specified if the VOLUME_CONDITION node
	// capability is supported.
	VolumeCondition *VolumeCondition `protobuf:"bytes,2,opt,name=volume_condition,json=volumeCondition,proto3" json:"volume_condition,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *NodeGetVolumeStatsResponse) Reset() {
	*x = NodeGetVolumeStatsResponse{}
	mi := &file_csi_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGetVolumeStatsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGetVolumeStatsResponse) ProtoMessage() {}

func (x *NodeGetVolumeStatsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGetVolumeStatsResponse.ProtoReflect.Descriptor instead.
func (*NodeGetVolumeStatsResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{54}
}

func (x *NodeGetVolumeStatsResponse) GetUsage() []*VolumeUsage {
	if x != nil {
		return x.Usage
	}
	return nil
}

func (x *NodeGetVolumeStatsResponse) GetVolumeCondition() *VolumeCondition {
	if x != nil {
		return x.VolumeCondition
	}
	return nil
}

type VolumeUsage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The available capacity in specified Unit. This field is OPTIONAL.
	// The value of this field MUST NOT be negative.
	Available int64 `protobuf:"varint,1,opt,name=available,proto3" json:"available,omitempty"`
	// The total capacity in specified Unit. This field is REQUIRED.
	// The value of this field MUST NOT be negative.
	Total int64 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	// The used capacity in specified Unit. This field is OPTIONAL.
	// The value of this field MUST NOT be negative.
	Used int64 `protobuf:"varint,3,opt,name=used,proto3" json:"used,omitempty"`
	// Units by which values are measured. This field is REQUIRED.
	Unit          VolumeUsage_Unit `protobuf:"varint,4,opt,name=unit,proto3,enum=csi.v1.VolumeUsage_Unit" json:"unit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeUsage) Reset() {
	*x = VolumeUsage{}
	mi := &file_csi_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeUsage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeUsage) ProtoMessage() {}

func (x *VolumeUsage) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeUsage.ProtoReflect.Descriptor instead.
func (*VolumeUsage) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{55}
}

func (x *VolumeUsage) GetAvailable() int64 {
	if x != nil {
		return x.Available
	}
	return 0
}

func (x *VolumeUsage) GetTotal() int64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *VolumeUsage) GetUsed() int64 {
	if x != nil {
		return x.Used
	}
	return 0
}

func (x *VolumeUsage) GetUnit() VolumeUsage_Unit {
	if x != nil {
		return x.Unit
	}
	return VolumeUsage_UNKNOWN
}

// VolumeCondition represents the current condition of a volume.
type VolumeCondition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Normal volumes are available for use and operating optimally.
	// An abnormal volume does not meet these criteria.
	// This field is REQUIRED.
	Abnormal bool `protobuf:"varint,1,opt,name=abnormal,proto3" json:"abnormal,omitempty"`
	// The message describing the condition of the volume.
	// This field is REQUIRED.
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeCondition) Reset() {
	*x = VolumeCondition{}
	mi := &file_csi_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeCondition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeCondition) ProtoMessage() {}

func (x *VolumeCondition) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeCondition.ProtoReflect.Descriptor instead.
func (*VolumeCondition) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{56}
}

func (x *VolumeCondition) GetAbnormal() bool {
	if x != nil {
		return x.Abnormal
	}
	return false
}

func (x *VolumeCondition) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type NodeGetCapabilitiesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGetCapabilitiesRequest) Reset() {
	*x = NodeGetCapabilitiesRequest{}
	mi := &file_csi_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGetCapabilitiesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGetCapabilitiesRequest) ProtoMessage() {}

func (x *NodeGetCapabilitiesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGetCapabilitiesRequest.ProtoReflect.Descriptor instead.
func (*NodeGetCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{57}
}

type NodeGetCapabilitiesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// All the capabilities that the node service supports. This field
	// is OPTIONAL.
	Capabilities  []*NodeServiceCapability `protobuf:"bytes,1,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGetCapabilitiesResponse) Reset() {
	*x = NodeGetCapabilitiesResponse{}
	mi := &file_csi_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGetCapabilitiesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGetCapabilitiesResponse) ProtoMessage() {}

func (x *NodeGetCapabilitiesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGetCapabilitiesResponse.ProtoReflect.Descriptor instead.
func (*NodeGetCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{58}
}

func (x *NodeGetCapabilitiesResponse) GetCapabilities() []*NodeServiceCapability {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

// Specifies a capability of the node service.
type NodeServiceCapability struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*NodeServiceCapability_Rpc
	Type          isNodeServiceCapability_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeServiceCapability) Reset() {
	*x = NodeServiceCapability{}
	mi := &file_csi_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeServiceCapability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeServiceCapability) ProtoMessage() {}

func (x *NodeServiceCapability) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeServiceCapability.ProtoReflect.Descriptor instead.
func (*NodeServiceCapability) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{59}
}

func (x *NodeServiceCapability) GetType() isNodeServiceCapability_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *NodeServiceCapability) GetRpc() *NodeServiceCapability_RPC {
	if x != nil {
		if x, ok := x.Type.(*NodeServiceCapability_Rpc); ok {
			return x.Rpc
		}
	}
	return nil
}

type isNodeServiceCapability_Type interface {
	isNodeServiceCapability_Type()
}

type NodeServiceCapability_Rpc struct {
	// RPC that the controller supports.
	Rpc *NodeServiceCapability_RPC `protobuf:"bytes,1,opt,name=rpc,proto3,oneof"`
}

func (*NodeServiceCapability_Rpc) isNodeServiceCapability_Type() {}

type NodeGetInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGetInfoRequest) Reset() {
	*x = NodeGetInfoRequest{}
	mi := &file_csi_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGetInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGetInfoRequest) ProtoMessage() {}

func (x *NodeGetInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGetInfoRequest.ProtoReflect.Descriptor instead.
func (*NodeGetInfoRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{60}
}

type NodeGetInfoResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifier of the node as understood by the SP.
	// This field is REQUIRED.
	// This field MUST contain enough information to uniquely identify
	// this specific node vs all other nodes supported by this plugin.
	// This field SHALL be used by the CO in subsequent calls, including
	// `ControllerPublishVolume`, to refer to this node.
	// The SP is NOT responsible for global uniqueness of node_id across
	// multiple SPs.
	// This field overrides the general CSI size limit.
	// The size of this field SHALL NOT exceed 256 bytes. The general
	// CSI size limit, 128 byte, is RECOMMENDED for best backwards
	// compatibility.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Maximum number of volumes that controller can publish to the node.
	// If value is not set or zero CO SHALL decide how many volumes of
	// this type can be published by the controller to the node. The
	// plugin MUST NOT set negative values here.
	// This field is OPTIONAL.
	MaxVolumesPerNode int64 `protobuf:"varint,2,opt,name=max_volumes_per_node,json=maxVolumesPerNode,proto3" json:"max_volumes_per_node,omitempty"`
	// Specifies where (regions, zones, racks, etc.) the node is
	// accessible from.
	// A plugin that returns this field MUST also set the
	// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
	// COs MAY use this information along with the topology information
	// returned in CreateVolumeResponse to ensure that a given volume is
	// accessible from a given node when scheduling workloads.
	// This field is OPTIONAL. If it is not specified, the CO MAY assume
	// the node is not subject to any topological constraint, and MAY
	// schedule workloads that reference any volume V, such that there are
	// no topological constraints declared for V.
	//
	// Example 1:
	//
	//	accessible_topology =
	//	  {"region": "R1", "zone": "Z2"}
	//
	// Indicates the node exists within the "region" "R1" and the "zone"
	// "Z2".
	AccessibleTopology *Topology `protobuf:"bytes,3,opt,name=accessible_topology,json=accessibleTopology,proto3" json:"accessible_topology,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *NodeGetInfoResponse) Reset() {
	*x = NodeGetInfoResponse{}
	mi := &file_csi_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGetInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGetInfoResponse) ProtoMessage() {}

func (x *NodeGetInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGetInfoResponse.ProtoReflect.Descriptor instead.
func (*NodeGetInfoResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{61}
}

func (x *NodeGetInfoResponse) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeGetInfoResponse) GetMaxVolumesPerNode() int64 {
	if x != nil {
		return x.MaxVolumesPerNode
	}
	return 0
}

func (x *NodeGetInfoResponse) GetAccessibleTopology() *Topology {
	if x != nil {
		return x.AccessibleTopology
	}
	return nil
}

type NodeExpandVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the volume. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The path on which volume is available. This field is REQUIRED.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	VolumePath string `protobuf:"bytes,2,opt,name=volume_path,json=volumePath,proto3" json:"volume_path,omitempty"`
	// This allows CO to specify the capacity requirements of the volume
	// after expansion. If capacity_range is omitted then a plugin MAY
	// inspect the file system of the volume to determine the maximum
	// capacity to which the volume can be expanded. In such cases a
	// plugin MAY expand the volume to its maximum capacity.
	// This field is OPTIONAL.
	CapacityRange *CapacityRange `protobuf:"bytes,3,opt,name=capacity_range,json=capacityRange,proto3" json:"capacity_range,omitempty"`
	// The path where the volume is staged, if the plugin has the
	// STAGE_UNSTAGE_VOLUME capability, otherwise empty.
	// If not empty, it MUST be an absolute path in the root
	// filesystem of the process serving this request.
	// This field is OPTIONAL.
	// This field overrides the general CSI size limit.
	// SP SHOULD support the maximum path length allowed by the operating
	// system/filesystem, but, at a minimum, SP MUST accept a max path
	// length of at least 128 bytes.
	StagingTargetPath string `protobuf:"bytes,4,opt,name=staging_target_path,json=stagingTargetPath,proto3" json:"staging_target_path,omitempty"`
	// Volume capability describing how the CO intends to use this volume.
	// This allows SP to determine if volume is being used as a block
	// device or mounted file system. For example - if volume is being
	// used as a block device the SP MAY choose to skip expanding the
	// filesystem in NodeExpandVolume implementation but still perform
	// rest of the housekeeping needed for expanding the volume. If
	// volume_capability is omitted the SP MAY determine
	// access_type from given volume_path for the volume and perform
	// node expansion. This is an OPTIONAL field.
	VolumeCapability *VolumeCapability `protobuf:"bytes,5,opt,name=volume_capability,json=volumeCapability,proto3" json:"volume_capability,omitempty"`
	// Secrets required by plugin to complete node expand volume request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,6,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeExpandVolumeRequest) Reset() {
	*x = NodeExpandVolumeRequest{}
	mi := &file_csi_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeExpandVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeExpandVolumeRequest) ProtoMessage() {}

func (x *NodeExpandVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeExpandVolumeRequest.ProtoReflect.Descriptor instead.
func (*NodeExpandVolumeRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{62}
}

func (x *NodeExpandVolumeRequest) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

func (x *NodeExpandVolumeRequest) GetVolumePath() string {
	if x != nil {
		return x.VolumePath
	}
	return ""
}

func (x *NodeExpandVolumeRequest) GetCapacityRange() *CapacityRange {
	if x != nil {
		return x.CapacityRange
	}
	return nil
}

func (x *NodeExpandVolumeRequest) GetStagingTargetPath() string {
	if x != nil {
		return x.StagingTargetPath
	}
	return ""
}

func (x *NodeExpandVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if x != nil {
		return x.VolumeCapability
	}
	return nil
}

func (x *NodeExpandVolumeRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type NodeExpandVolumeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The capacity of the volume in bytes. This field is OPTIONAL.
	CapacityBytes int64 `protobuf:"varint,1,opt,name=capacity_bytes,json=capacityBytes,proto3" json:"capacity_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeExpandVolumeResponse) Reset() {
	*x = NodeExpandVolumeResponse{}
	mi := &file_csi_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeExpandVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeExpandVolumeResponse) ProtoMessage() {}

func (x *NodeExpandVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeExpandVolumeResponse.ProtoReflect.Descriptor instead.
func (*NodeExpandVolumeResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{63}
}

func (x *NodeExpandVolumeResponse) GetCapacityBytes() int64 {
	if x != nil {
		return x.CapacityBytes
	}
	return 0
}

type GroupControllerGetCapabilitiesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GroupControllerGetCapabilitiesRequest) Reset() {
	*x = GroupControllerGetCapabilitiesRequest{}
	mi := &file_csi_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GroupControllerGetCapabilitiesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GroupControllerGetCapabilitiesRequest) ProtoMessage() {}

func (x *GroupControllerGetCapabilitiesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GroupControllerGetCapabilitiesRequest.ProtoReflect.Descriptor instead.
func (*GroupControllerGetCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{64}
}

type GroupControllerGetCapabilitiesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// All the capabilities that the group controller service supports.
	// This field is OPTIONAL.
	Capabilities  []*GroupControllerServiceCapability `protobuf:"bytes,1,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GroupControllerGetCapabilitiesResponse) Reset() {
	*x = GroupControllerGetCapabilitiesResponse{}
	mi := &file_csi_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GroupControllerGetCapabilitiesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GroupControllerGetCapabilitiesResponse) ProtoMessage() {}

func (x *GroupControllerGetCapabilitiesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GroupControllerGetCapabilitiesResponse.ProtoReflect.Descriptor instead.
func (*GroupControllerGetCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{65}
}

func (x *GroupControllerGetCapabilitiesResponse) GetCapabilities() []*GroupControllerServiceCapability {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

// Specifies a capability of the group controller service.
type GroupControllerServiceCapability struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*GroupControllerServiceCapability_Rpc
	Type          isGroupControllerServiceCapability_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GroupControllerServiceCapability) Reset() {
	*x = GroupControllerServiceCapability{}
	mi := &file_csi_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GroupControllerServiceCapability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GroupControllerServiceCapability) ProtoMessage() {}

func (x *GroupControllerServiceCapability) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GroupControllerServiceCapability.ProtoReflect.Descriptor instead.
func (*GroupControllerServiceCapability) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{66}
}

func (x *GroupControllerServiceCapability) GetType() isGroupControllerServiceCapability_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *GroupControllerServiceCapability) GetRpc() *GroupControllerServiceCapability_RPC {
	if x != nil {
		if x, ok := x.Type.(*GroupControllerServiceCapability_Rpc); ok {
			return x.Rpc
		}
	}
	return nil
}

type isGroupControllerServiceCapability_Type interface {
	isGroupControllerServiceCapability_Type()
}

type GroupControllerServiceCapability_Rpc struct {
	// RPC that the controller supports.
	Rpc *GroupControllerServiceCapability_RPC `protobuf:"bytes,1,opt,name=rpc,proto3,oneof"`
}

func (*GroupControllerServiceCapability_Rpc) isGroupControllerServiceCapability_Type() {}

type CreateVolumeGroupSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The suggested name for the group snapshot. This field is REQUIRED
	// for idempotency.
	// Any Unicode string that conforms to the length limit is allowed
	// except those containing the following banned characters:
	// U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
	// (These are control characters other than commonly used whitespace.)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// volume IDs of the source volumes to be snapshotted together.
	// This field is REQUIRED.
	SourceVolumeIds []string `protobuf:"bytes,2,rep,name=source_volume_ids,json=sourceVolumeIds,proto3" json:"source_volume_ids,omitempty"`
	// Secrets required by plugin to complete
	// ControllerCreateVolumeGroupSnapshot request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	// The secrets provided in this field SHOULD be the same for
	// all group snapshot operations on the same group snapshot.
	Secrets map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Plugin specific parameters passed in as opaque key-value pairs.
	// This field is OPTIONAL. The Plugin is responsible for parsing and
	// validating these parameters. COs will treat these as opaque.
	Parameters    map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateVolumeGroupSnapshotRequest) Reset() {
	*x = CreateVolumeGroupSnapshotRequest{}
	mi := &file_csi_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateVolumeGroupSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateVolumeGroupSnapshotRequest) ProtoMessage() {}

func (x *CreateVolumeGroupSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateVolumeGroupSnapshotRequest.ProtoReflect.Descriptor instead.
func (*CreateVolumeGroupSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{67}
}

func (x *CreateVolumeGroupSnapshotRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateVolumeGroupSnapshotRequest) GetSourceVolumeIds() []string {
	if x != nil {
		return x.SourceVolumeIds
	}
	return nil
}

func (x *CreateVolumeGroupSnapshotRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

func (x *CreateVolumeGroupSnapshotRequest) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

type CreateVolumeGroupSnapshotResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Contains all attributes of the newly created group snapshot.
	// This field is REQUIRED.
	GroupSnapshot *VolumeGroupSnapshot `protobuf:"bytes,1,opt,name=group_snapshot,json=groupSnapshot,proto3" json:"group_snapshot,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateVolumeGroupSnapshotResponse) Reset() {
	*x = CreateVolumeGroupSnapshotResponse{}
	mi := &file_csi_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateVolumeGroupSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateVolumeGroupSnapshotResponse) ProtoMessage() {}

func (x *CreateVolumeGroupSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateVolumeGroupSnapshotResponse.ProtoReflect.Descriptor instead.
func (*CreateVolumeGroupSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{68}
}

func (x *CreateVolumeGroupSnapshotResponse) GetGroupSnapshot() *VolumeGroupSnapshot {
	if x != nil {
		return x.GroupSnapshot
	}
	return nil
}

type VolumeGroupSnapshot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifier for this group snapshot, generated by the plugin.
	// This field MUST contain enough information to uniquely identify
	// this specific snapshot vs all other group snapshots supported by
	// this plugin.
	// This field SHALL be used by the CO in subsequent calls to refer to
	// this group snapshot.
	// The SP is NOT responsible for global uniqueness of
	// group_snapshot_id across multiple SPs.
	// This field is REQUIRED.
	GroupSnapshotId string `protobuf:"bytes,1,opt,name=group_snapshot_id,json=groupSnapshotId,proto3" json:"group_snapshot_id,omitempty"`
	// A list of snapshots belonging to this group.
	// This field is REQUIRED.
	Snapshots []*Snapshot `protobuf:"bytes,2,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
	// Timestamp of when the volume group snapshot was taken.
	// This field is REQUIRED.
	CreationTime *timestamp.Timestamp `protobuf:"bytes,3,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// Indicates if all individual snapshots in the group snapshot
	// are ready to use as a `volume_content_source` in a
	// `CreateVolumeRequest`. The default value is false.
	// If any snapshot in the list of snapshots in this message have
	// ready_to_use set to false, the SP MUST set this field to false.
	// If all of the snapshots in the list of snapshots in this message
	// have ready_to_use set to true, the SP SHOULD set this field to
	// true.
	// This field is REQUIRED.
	ReadyToUse    bool `protobuf:"varint,4,opt,name=ready_to_use,json=readyToUse,proto3" json:"ready_to_use,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeGroupSnapshot) Reset() {
	*x = VolumeGroupSnapshot{}
	mi := &file_csi_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeGroupSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeGroupSnapshot) ProtoMessage() {}

func (x *VolumeGroupSnapshot) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeGroupSnapshot.ProtoReflect.Descriptor instead.
func (*VolumeGroupSnapshot) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{69}
}

func (x *VolumeGroupSnapshot) GetGroupSnapshotId() string {
	if x != nil {
		return x.GroupSnapshotId
	}
	return ""
}

func (x *VolumeGroupSnapshot) GetSnapshots() []*Snapshot {
	if x != nil {
		return x.Snapshots
	}
	return nil
}

func (x *VolumeGroupSnapshot) GetCreationTime() *timestamp.Timestamp {
	if x != nil {
		return x.CreationTime
	}
	return nil
}

func (x *VolumeGroupSnapshot) GetReadyToUse() bool {
	if x != nil {
		return x.ReadyToUse
	}
	return false
}

type DeleteVolumeGroupSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the group snapshot to be deleted.
	// This field is REQUIRED.
	GroupSnapshotId string `protobuf:"bytes,1,opt,name=group_snapshot_id,json=groupSnapshotId,proto3" json:"group_snapshot_id,omitempty"`
	// A list of snapshot IDs that are part of this group snapshot.
	// If SP does not need to rely on this field to delete the snapshots
	// in the group, it SHOULD check this field and report an error
	// if it has the ability to detect a mismatch.
	// Some SPs require this list to delete the snapshots in the group.
	// If SP needs to use this field to delete the snapshots in the
	// group, it MUST report an error if it has the ability to detect
	// a mismatch.
	// This field is REQUIRED.
	SnapshotIds []string `protobuf:"bytes,2,rep,name=snapshot_ids,json=snapshotIds,proto3" json:"snapshot_ids,omitempty"`
	// Secrets required by plugin to complete group snapshot deletion
	// request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	// The secrets provided in this field SHOULD be the same for
	// all group snapshot operations on the same group snapshot.
	Secrets       map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteVolumeGroupSnapshotRequest) Reset() {
	*x = DeleteVolumeGroupSnapshotRequest{}
	mi := &file_csi_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteVolumeGroupSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteVolumeGroupSnapshotRequest) ProtoMessage() {}

func (x *DeleteVolumeGroupSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteVolumeGroupSnapshotRequest.ProtoReflect.Descriptor instead.
func (*DeleteVolumeGroupSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{70}
}

func (x *DeleteVolumeGroupSnapshotRequest) GetGroupSnapshotId() string {
	if x != nil {
		return x.GroupSnapshotId
	}
	return ""
}

func (x *DeleteVolumeGroupSnapshotRequest) GetSnapshotIds() []string {
	if x != nil {
		return x.SnapshotIds
	}
	return nil
}

func (x *DeleteVolumeGroupSnapshotRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type DeleteVolumeGroupSnapshotResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteVolumeGroupSnapshotResponse) Reset() {
	*x = DeleteVolumeGroupSnapshotResponse{}
	mi := &file_csi_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteVolumeGroupSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteVolumeGroupSnapshotResponse) ProtoMessage() {}

func (x *DeleteVolumeGroupSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteVolumeGroupSnapshotResponse.ProtoReflect.Descriptor instead.
func (*DeleteVolumeGroupSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{71}
}

type GetVolumeGroupSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the group snapshot to fetch current group snapshot
	// information for.
	// This field is REQUIRED.
	GroupSnapshotId string `protobuf:"bytes,1,opt,name=group_snapshot_id,json=groupSnapshotId,proto3" json:"group_snapshot_id,omitempty"`
	// A list of snapshot IDs that are part of this group snapshot.
	// If SP does not need to rely on this field to get the snapshots
	// in the group, it SHOULD check this field and report an error
	// if it has the ability to detect a mismatch.
	// Some SPs require this list to get the snapshots in the group.
	// If SP needs to use this field to get the snapshots in the
	// group, it MUST report an error if it has the ability to detect
	// a mismatch.
	// This field is REQUIRED.
	SnapshotIds []string `protobuf:"bytes,2,rep,name=snapshot_ids,json=snapshotIds,proto3" json:"snapshot_ids,omitempty"`
	// Secrets required by plugin to complete
	// GetVolumeGroupSnapshot request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	// The secrets provided in this field SHOULD be the same for
	// all group snapshot operations on the same group snapshot.
	Secrets       map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetVolumeGroupSnapshotRequest) Reset() {
	*x = GetVolumeGroupSnapshotRequest{}
	mi := &file_csi_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetVolumeGroupSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetVolumeGroupSnapshotRequest) ProtoMessage() {}

func (x *GetVolumeGroupSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetVolumeGroupSnapshotRequest.ProtoReflect.Descriptor instead.
func (*GetVolumeGroupSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{72}
}

func (x *GetVolumeGroupSnapshotRequest) GetGroupSnapshotId() string {
	if x != nil {
		return x.GroupSnapshotId
	}
	return ""
}

func (x *GetVolumeGroupSnapshotRequest) GetSnapshotIds() []string {
	if x != nil {
		return x.SnapshotIds
	}
	return nil
}

func (x *GetVolumeGroupSnapshotRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

type GetVolumeGroupSnapshotResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is REQUIRED
	GroupSnapshot *VolumeGroupSnapshot `protobuf:"bytes,1,opt,name=group_snapshot,json=groupSnapshot,proto3" json:"group_snapshot,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetVolumeGroupSnapshotResponse) Reset() {
	*x = GetVolumeGroupSnapshotResponse{}
	mi := &file_csi_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetVolumeGroupSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetVolumeGroupSnapshotResponse) ProtoMessage() {}

func (x *GetVolumeGroupSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetVolumeGroupSnapshotResponse.ProtoReflect.Descriptor instead.
func (*GetVolumeGroupSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{73}
}

func (x *GetVolumeGroupSnapshotResponse) GetGroupSnapshot() *VolumeGroupSnapshot {
	if x != nil {
		return x.GroupSnapshot
	}
	return nil
}

// BlockMetadata specifies a data range.
type BlockMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the zero based byte position in the volume or snapshot,
	// measured from the start of the object.
	// This field is REQUIRED.
	ByteOffset int64 `protobuf:"varint,1,opt,name=byte_offset,json=byteOffset,proto3" json:"byte_offset,omitempty"`
	// This is the size of the data range.
	// size_bytes MUST be greater than zero.
	// This field is REQUIRED.
	SizeBytes     int64 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlockMetadata) Reset() {
	*x = BlockMetadata{}
	mi := &file_csi_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockMetadata) ProtoMessage() {}

func (x *BlockMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockMetadata.ProtoReflect.Descriptor instead.
func (*BlockMetadata) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{74}
}

func (x *BlockMetadata) GetByteOffset() int64 {
	if x != nil {
		return x.ByteOffset
	}
	return 0
}

func (x *BlockMetadata) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

// The GetMetadataAllocatedRequest message is used to solicit metadata
// on the allocated blocks of a snapshot: i.e. this identifies the
// data ranges that have valid data as they were the target of some
// previous write operation on the volume.
type GetMetadataAllocatedRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the identifier of the snapshot.
	// This field is REQUIRED.
	SnapshotId string `protobuf:"bytes,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// This indicates the zero based starting byte position in the volume
	// snapshot from which the result should be computed.
	// It is intended to be used to continue a previously interrupted
	// call.
	// The CO SHOULD specify this value to be the offset of the byte
	// position immediately after the last byte of the last data range
	// received, if continuing an interrupted operation, or zero if not.
	// The SP MUST ensure that the returned response stream does not
	// contain BlockMetadata tuples that end before the requested
	// starting_offset: i.e. if S is the requested starting_offset, and
	// B0 is block_metadata[0] of the first message in the response
	// stream, then (S < B0.byte_offset + B0.size_bytes) must be true.
	// This field is REQUIRED.
	StartingOffset int64 `protobuf:"varint,2,opt,name=starting_offset,json=startingOffset,proto3" json:"starting_offset,omitempty"`
	// This is an optional parameter, and if non-zero it specifies the
	// maximum number of tuples to be returned in each
	// GetMetadataAllocatedResponse message returned by the RPC stream.
	// The plugin will determine an appropriate value if 0, and is
	// always free to send less than the requested value.
	// This field is OPTIONAL.
	MaxResults int32 `protobuf:"varint,3,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
	// Secrets required by plugin to complete the request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,4,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMetadataAllocatedRequest) Reset() {
	*x = GetMetadataAllocatedRequest{}
	mi := &file_csi_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMetadataAllocatedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMetadataAllocatedRequest) ProtoMessage() {}

func (x *GetMetadataAllocatedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMetadataAllocatedRequest.ProtoReflect.Descriptor instead.
func (*GetMetadataAllocatedRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{75}
}

func (x *GetMetadataAllocatedRequest) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

func (x *GetMetadataAllocatedRequest) GetStartingOffset() int64 {
	if x != nil {
		return x.StartingOffset
	}
	return 0
}

func (x *GetMetadataAllocatedRequest) GetMaxResults() int32 {
	if x != nil {
		return x.MaxResults
	}
	return 0
}

func (x *GetMetadataAllocatedRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

// GetMetadataAllocatedResponse messages are returned in a gRPC stream.
// Cumulatively, they provide information on the allocated data
// ranges in the snapshot.
type GetMetadataAllocatedResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This specifies the style used in the BlockMetadata sequence.
	// This value must be the same in all such messages returned by
	// the stream.
	// If block_metadata_type is FIXED_LENGTH, then the size_bytes field
	// of each message in the block_metadata list MUST be constant.
	// This field is REQUIRED.
	BlockMetadataType BlockMetadataType `protobuf:"varint,1,opt,name=block_metadata_type,json=blockMetadataType,proto3,enum=csi.v1.BlockMetadataType" json:"block_metadata_type,omitempty"`
	// This returns the capacity of the underlying volume in bytes.
	// This value must be the same in all such messages returned by
	// the stream.
	// This field is REQUIRED.
	VolumeCapacityBytes int64 `protobuf:"varint,2,opt,name=volume_capacity_bytes,json=volumeCapacityBytes,proto3" json:"volume_capacity_bytes,omitempty"`
	// This is a list of data range tuples.
	// If the value of max_results in the GetMetadataAllocatedRequest
	// message is greater than zero, then the number of entries in this
	// list MUST be less than or equal to that value.
	// The SP MUST respect the value of starting_offset in the request.
	// The byte_offset fields of adjacent BlockMetadata messages
	// MUST be strictly increasing and messages MUST NOT overlap:
	// i.e. for any two BlockMetadata messages, A and B, if A is returned
	// before B, then (A.byte_offset + A.size_bytes <= B.byte_offset)
	// MUST be true.
	// This MUST also be true if A and B are from block_metadata lists in
	// different GetMetadataAllocatedResponse messages in the gRPC stream.
	// This field is OPTIONAL.
	BlockMetadata []*BlockMetadata `protobuf:"bytes,3,rep,name=block_metadata,json=blockMetadata,proto3" json:"block_metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMetadataAllocatedResponse) Reset() {
	*x = GetMetadataAllocatedResponse{}
	mi := &file_csi_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMetadataAllocatedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMetadataAllocatedResponse) ProtoMessage() {}

func (x *GetMetadataAllocatedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMetadataAllocatedResponse.ProtoReflect.Descriptor instead.
func (*GetMetadataAllocatedResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{76}
}

func (x *GetMetadataAllocatedResponse) GetBlockMetadataType() BlockMetadataType {
	if x != nil {
		return x.BlockMetadataType
	}
	return BlockMetadataType_UNKNOWN
}

func (x *GetMetadataAllocatedResponse) GetVolumeCapacityBytes() int64 {
	if x != nil {
		return x.VolumeCapacityBytes
	}
	return 0
}

func (x *GetMetadataAllocatedResponse) GetBlockMetadata() []*BlockMetadata {
	if x != nil {
		return x.BlockMetadata
	}
	return nil
}

// The GetMetadataDeltaRequest message is used to solicit metadata on
// the data ranges that have changed between two snapshots.
type GetMetadataDeltaRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the identifier of the snapshot against which changes
	// are to be computed.
	// This field is REQUIRED.
	BaseSnapshotId string `protobuf:"bytes,1,opt,name=base_snapshot_id,json=baseSnapshotId,proto3" json:"base_snapshot_id,omitempty"`
	// This is the identifier of a second snapshot in the same volume,
	// created after the base snapshot.
	// This field is REQUIRED.
	TargetSnapshotId string `protobuf:"bytes,2,opt,name=target_snapshot_id,json=targetSnapshotId,proto3" json:"target_snapshot_id,omitempty"`
	// This indicates the zero based starting byte position in the volume
	// snapshot from which the result should be computed.
	// It is intended to be used to continue a previously interrupted
	// call.
	// The CO SHOULD specify this value to be the offset of the byte
	// position immediately after the last byte of the last data range
	// received, if continuing an interrupted operation, or zero if not.
	// The SP MUST ensure that the returned response stream does not
	// contain BlockMetadata tuples that end before the requested
	// starting_offset: i.e. if S is the requested starting_offset, and
	// B0 is block_metadata[0] of the first message in the response
	// stream, then (S < B0.byte_offset + B0.size_bytes) must be true.
	// This field is REQUIRED.
	StartingOffset int64 `protobuf:"varint,3,opt,name=starting_offset,json=startingOffset,proto3" json:"starting_offset,omitempty"`
	// This is an optional parameter, and if non-zero it specifies the
	// maximum number of tuples to be returned in each
	// GetMetadataDeltaResponse message returned by the RPC stream.
	// The plugin will determine an appropriate value if 0, and is
	// always free to send less than the requested value.
	// This field is OPTIONAL.
	MaxResults int32 `protobuf:"varint,4,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
	// Secrets required by plugin to complete the request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets       map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMetadataDeltaRequest) Reset() {
	*x = GetMetadataDeltaRequest{}
	mi := &file_csi_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMetadataDeltaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMetadataDeltaRequest) ProtoMessage() {}

func (x *GetMetadataDeltaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMetadataDeltaRequest.ProtoReflect.Descriptor instead.
func (*GetMetadataDeltaRequest) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{77}
}

func (x *GetMetadataDeltaRequest) GetBaseSnapshotId() string {
	if x != nil {
		return x.BaseSnapshotId
	}
	return ""
}

func (x *GetMetadataDeltaRequest) GetTargetSnapshotId() string {
	if x != nil {
		return x.TargetSnapshotId
	}
	return ""
}

func (x *GetMetadataDeltaRequest) GetStartingOffset() int64 {
	if x != nil {
		return x.StartingOffset
	}
	return 0
}

func (x *GetMetadataDeltaRequest) GetMaxResults() int32 {
	if x != nil {
		return x.MaxResults
	}
	return 0
}

func (x *GetMetadataDeltaRequest) GetSecrets() map[string]string {
	if x != nil {
		return x.Secrets
	}
	return nil
}

// GetMetadataDeltaResponse messages are returned in a gRPC stream.
// Cumulatively, they provide information on the data ranges that
// have changed between the base and target snapshots specified
// in the GetMetadataDeltaRequest message.
type GetMetadataDeltaResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This specifies the style used in the BlockMetadata sequence.
	// This value must be the same in all such messages returned by
	// the stream.
	// If block_metadata_type is FIXED_LENGTH, then the size_bytes field
	// of each message in the block_metadata list MUST be constant.
	// This field is REQUIRED.
	BlockMetadataType BlockMetadataType `protobuf:"varint,1,opt,name=block_metadata_type,json=blockMetadataType,proto3,enum=csi.v1.BlockMetadataType" json:"block_metadata_type,omitempty"`
	// This returns the capacity of the underlying volume in bytes.
	// This value must be the same in all such messages returned by
	// the stream.
	// This field is REQUIRED.
	VolumeCapacityBytes int64 `protobuf:"varint,2,opt,name=volume_capacity_bytes,json=volumeCapacityBytes,proto3" json:"volume_capacity_bytes,omitempty"`
	// This is a list of data range tuples.
	// If the value of max_results in the GetMetadataDeltaRequest message
	// is greater than zero, then the number of entries in this list MUST
	// be less than or equal to that value.
	// The SP MUST respect the value of starting_offset in the request.
	// The byte_offset fields of adjacent BlockMetadata messages
	// MUST be strictly increasing and messages MUST NOT overlap:
	// i.e. for any two BlockMetadata messages, A and B, if A is returned
	// before B, then (A.byte_offset + A.size_bytes <= B.byte_offset)
	// MUST be true.
	// This MUST also be true if A and B are from block_metadata lists in
	// different GetMetadataDeltaResponse messages in the gRPC stream.
	// This field is OPTIONAL.
	BlockMetadata []*BlockMetadata `protobuf:"bytes,3,rep,name=block_metadata,json=blockMetadata,proto3" json:"block_metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMetadataDeltaResponse) Reset() {
	*x = GetMetadataDeltaResponse{}
	mi := &file_csi_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMetadataDeltaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMetadataDeltaResponse) ProtoMessage() {}

func (x *GetMetadataDeltaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMetadataDeltaResponse.ProtoReflect.Descriptor instead.
func (*GetMetadataDeltaResponse) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{78}
}

func (x *GetMetadataDeltaResponse) GetBlockMetadataType() BlockMetadataType {
	if x != nil {
		return x.BlockMetadataType
	}
	return BlockMetadataType_UNKNOWN
}

func (x *GetMetadataDeltaResponse) GetVolumeCapacityBytes() int64 {
	if x != nil {
		return x.VolumeCapacityBytes
	}
	return 0
}

func (x *GetMetadataDeltaResponse) GetBlockMetadata() []*BlockMetadata {
	if x != nil {
		return x.BlockMetadata
	}
	return nil
}

type PluginCapability_Service struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	Type          PluginCapability_Service_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.PluginCapability_Service_Type" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginCapability_Service) Reset() {
	*x = PluginCapability_Service{}
	mi := &file_csi_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginCapability_Service) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginCapability_Service) ProtoMessage() {}

func (x *PluginCapability_Service) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginCapability_Service.ProtoReflect.Descriptor instead.
func (*PluginCapability_Service) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{4, 0}
}

func (x *PluginCapability_Service) GetType() PluginCapability_Service_Type {
	if x != nil {
		return x.Type
	}
	return PluginCapability_Service_UNKNOWN
}

type PluginCapability_VolumeExpansion struct {
	state         protoimpl.MessageState                `protogen:"open.v1"`
	Type          PluginCapability_VolumeExpansion_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.PluginCapability_VolumeExpansion_Type" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginCapability_VolumeExpansion) Reset() {
	*x = PluginCapability_VolumeExpansion{}
	mi := &file_csi_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginCapability_VolumeExpansion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginCapability_VolumeExpansion) ProtoMessage() {}

func (x *PluginCapability_VolumeExpansion) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginCapability_VolumeExpansion.ProtoReflect.Descriptor instead.
func (*PluginCapability_VolumeExpansion) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{4, 1}
}

func (x *PluginCapability_VolumeExpansion) GetType() PluginCapability_VolumeExpansion_Type {
	if x != nil {
		return x.Type
	}
	return PluginCapability_VolumeExpansion_UNKNOWN
}

type VolumeContentSource_SnapshotSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Contains identity information for the existing source snapshot.
	// This field is REQUIRED. Plugin is REQUIRED to support creating
	// volume from snapshot if it supports the capability
	// CREATE_DELETE_SNAPSHOT.
	SnapshotId    string `protobuf:"bytes,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeContentSource_SnapshotSource) Reset() {
	*x = VolumeContentSource_SnapshotSource{}
	mi := &file_csi_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeContentSource_SnapshotSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeContentSource_SnapshotSource) ProtoMessage() {}

func (x *VolumeContentSource_SnapshotSource) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeContentSource_SnapshotSource.ProtoReflect.Descriptor instead.
func (*VolumeContentSource_SnapshotSource) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{8, 0}
}

func (x *VolumeContentSource_SnapshotSource) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

type VolumeContentSource_VolumeSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Contains identity information for the existing source volume.
	// This field is REQUIRED. Plugins reporting CLONE_VOLUME
	// capability MUST support creating a volume from another volume.
	VolumeId      string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeContentSource_VolumeSource) Reset() {
	*x = VolumeContentSource_VolumeSource{}
	mi := &file_csi_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeContentSource_VolumeSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeContentSource_VolumeSource) ProtoMessage() {}

func (x *VolumeContentSource_VolumeSource) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeContentSource_VolumeSource.ProtoReflect.Descriptor instead.
func (*VolumeContentSource_VolumeSource) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{8, 1}
}

func (x *VolumeContentSource_VolumeSource) GetVolumeId() string {
	if x != nil {
		return x.VolumeId
	}
	return ""
}

// Indicate that the volume will be accessed via the block device API.
type VolumeCapability_BlockVolume struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeCapability_BlockVolume) Reset() {
	*x = VolumeCapability_BlockVolume{}
	mi := &file_csi_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeCapability_BlockVolume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeCapability_BlockVolume) ProtoMessage() {}

func (x *VolumeCapability_BlockVolume) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeCapability_BlockVolume.ProtoReflect.Descriptor instead.
func (*VolumeCapability_BlockVolume) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{10, 0}
}

// Indicate that the volume will be accessed via the filesystem API.
type VolumeCapability_MountVolume struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The filesystem type. This field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	FsType string `protobuf:"bytes,1,opt,name=fs_type,json=fsType,proto3" json:"fs_type,omitempty"`
	// The mount options that can be used for the volume. This field is
	// OPTIONAL. `mount_flags` MAY contain sensitive information.
	// Therefore, the CO and the Plugin MUST NOT leak this information
	// to untrusted entities. The total size of this repeated field
	// SHALL NOT exceed 4 KiB.
	MountFlags []string `protobuf:"bytes,2,rep,name=mount_flags,json=mountFlags,proto3" json:"mount_flags,omitempty"`
	// If SP has VOLUME_MOUNT_GROUP node capability and CO provides
	// this field then SP MUST ensure that the volume_mount_group
	// parameter is passed as the group identifier to the underlying
	// operating system mount system call, with the understanding
	// that the set of available mount call parameters and/or
	// mount implementations may vary across operating systems.
	// Additionally, new file and/or directory entries written to
	// the underlying filesystem SHOULD be permission-labeled in such a
	// manner, unless otherwise modified by a workload, that they are
	// both readable and writable by said mount group identifier.
	// This is an OPTIONAL field.
	VolumeMountGroup string `protobuf:"bytes,3,opt,name=volume_mount_group,json=volumeMountGroup,proto3" json:"volume_mount_group,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VolumeCapability_MountVolume) Reset() {
	*x = VolumeCapability_MountVolume{}
	mi := &file_csi_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeCapability_MountVolume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeCapability_MountVolume) ProtoMessage() {}

func (x *VolumeCapability_MountVolume) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeCapability_MountVolume.ProtoReflect.Descriptor instead.
func (*VolumeCapability_MountVolume) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{10, 1}
}

func (x *VolumeCapability_MountVolume) GetFsType() string {
	if x != nil {
		return x.FsType
	}
	return ""
}

func (x *VolumeCapability_MountVolume) GetMountFlags() []string {
	if x != nil {
		return x.MountFlags
	}
	return nil
}

func (x *VolumeCapability_MountVolume) GetVolumeMountGroup() string {
	if x != nil {
		return x.VolumeMountGroup
	}
	return ""
}

// Specify how a volume can be accessed.
type VolumeCapability_AccessMode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is REQUIRED.
	Mode          VolumeCapability_AccessMode_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=csi.v1.VolumeCapability_AccessMode_Mode" json:"mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeCapability_AccessMode) Reset() {
	*x = VolumeCapability_AccessMode{}
	mi := &file_csi_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeCapability_AccessMode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeCapability_AccessMode) ProtoMessage() {}

func (x *VolumeCapability_AccessMode) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeCapability_AccessMode.ProtoReflect.Descriptor instead.
func (*VolumeCapability_AccessMode) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{10, 2}
}

func (x *VolumeCapability_AccessMode) GetMode() VolumeCapability_AccessMode_Mode {
	if x != nil {
		return x.Mode
	}
	return VolumeCapability_AccessMode_UNKNOWN
}

type ValidateVolumeCapabilitiesResponse_Confirmed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Volume context validated by the plugin.
	// This field is OPTIONAL.
	VolumeContext map[string]string `protobuf:"bytes,1,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Volume capabilities supported by the plugin.
	// This field is REQUIRED.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,2,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// The volume creation parameters validated by the plugin.
	// This field is OPTIONAL.
	Parameters map[string]string `protobuf:"bytes,3,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The volume creation mutable_parameters validated by the plugin.
	// This field is OPTIONAL.
	MutableParameters map[string]string `protobuf:"bytes,4,rep,name=mutable_parameters,json=mutableParameters,proto3" json:"mutable_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ValidateVolumeCapabilitiesResponse_Confirmed) Reset() {
	*x = ValidateVolumeCapabilitiesResponse_Confirmed{}
	mi := &file_csi_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateVolumeCapabilitiesResponse_Confirmed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateVolumeCapabilitiesResponse_Confirmed) ProtoMessage() {}

func (x *ValidateVolumeCapabilitiesResponse_Confirmed) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateVolumeCapabilitiesResponse_Confirmed.ProtoReflect.Descriptor instead.
func (*ValidateVolumeCapabilitiesResponse_Confirmed) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{22, 0}
}

func (x *ValidateVolumeCapabilitiesResponse_Confirmed) GetVolumeContext() map[string]string {
	if x != nil {
		return x.VolumeContext
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesResponse_Confirmed) GetVolumeCapabilities() []*VolumeCapability {
	if x != nil {
		return x.VolumeCapabilities
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesResponse_Confirmed) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

func (x *ValidateVolumeCapabilitiesResponse_Confirmed) GetMutableParameters() map[string]string {
	if x != nil {
		return x.MutableParameters
	}
	return nil
}

type ListVolumesResponse_VolumeStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of all `node_id` of nodes that the volume in this entry
	// is controller published on.
	// This field is OPTIONAL. If it is not specified and the SP has
	// the LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO
	// MAY assume the volume is not controller published to any nodes.
	// If the field is not specified and the SP does not have the
	// LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO MUST
	// not interpret this field.
	// published_node_ids MAY include nodes not published to or
	// reported by the SP. The CO MUST be resilient to that.
	PublishedNodeIds []string `protobuf:"bytes,1,rep,name=published_node_ids,json=publishedNodeIds,proto3" json:"published_node_ids,omitempty"`
	// Information about the current condition of the volume.
	// This field is OPTIONAL.
	// This field MUST be specified if the
	// VOLUME_CONDITION controller capability is supported.
	VolumeCondition *VolumeCondition `protobuf:"bytes,2,opt,name=volume_condition,json=volumeCondition,proto3" json:"volume_condition,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListVolumesResponse_VolumeStatus) Reset() {
	*x = ListVolumesResponse_VolumeStatus{}
	mi := &file_csi_proto_msgTypes[105]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListVolumesResponse_VolumeStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListVolumesResponse_VolumeStatus) ProtoMessage() {}

func (x *ListVolumesResponse_VolumeStatus) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[105]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListVolumesResponse_VolumeStatus.ProtoReflect.Descriptor instead.
func (*ListVolumesResponse_VolumeStatus) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{24, 0}
}

func (x *ListVolumesResponse_VolumeStatus) GetPublishedNodeIds() []string {
	if x != nil {
		return x.PublishedNodeIds
	}
	return nil
}

func (x *ListVolumesResponse_VolumeStatus) GetVolumeCondition() *VolumeCondition {
	if x != nil {
		return x.VolumeCondition
	}
	return nil
}

type ListVolumesResponse_Entry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is REQUIRED
	Volume *Volume `protobuf:"bytes,1,opt,name=volume,proto3" json:"volume,omitempty"`
	// This field is OPTIONAL. This field MUST be specified if the
	// LIST_VOLUMES_PUBLISHED_NODES controller capability is
	// supported.
	Status        *ListVolumesResponse_VolumeStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListVolumesResponse_Entry) Reset() {
	*x = ListVolumesResponse_Entry{}
	mi := &file_csi_proto_msgTypes[106]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListVolumesResponse_Entry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListVolumesResponse_Entry) ProtoMessage() {}

func (x *ListVolumesResponse_Entry) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[106]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListVolumesResponse_Entry.ProtoReflect.Descriptor instead.
func (*ListVolumesResponse_Entry) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{24, 1}
}

func (x *ListVolumesResponse_Entry) GetVolume() *Volume {
	if x != nil {
		return x.Volume
	}
	return nil
}

func (x *ListVolumesResponse_Entry) GetStatus() *ListVolumesResponse_VolumeStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type ControllerGetVolumeResponse_VolumeStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of all the `node_id` of nodes that this volume is
	// controller published on.
	// This field is OPTIONAL.
	// This field MUST be specified if the LIST_VOLUMES_PUBLISHED_NODES
	// controller capability is supported.
	// published_node_ids MAY include nodes not published to or
	// reported by the SP. The CO MUST be resilient to that.
	PublishedNodeIds []string `protobuf:"bytes,1,rep,name=published_node_ids,json=publishedNodeIds,proto3" json:"published_node_ids,omitempty"`
	// Information about the current condition of the volume.
	// This field is OPTIONAL.
	// This field MUST be specified if the
	// VOLUME_CONDITION controller capability is supported.
	VolumeCondition *VolumeCondition `protobuf:"bytes,2,opt,name=volume_condition,json=volumeCondition,proto3" json:"volume_condition,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ControllerGetVolumeResponse_VolumeStatus) Reset() {
	*x = ControllerGetVolumeResponse_VolumeStatus{}
	mi := &file_csi_proto_msgTypes[107]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerGetVolumeResponse_VolumeStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerGetVolumeResponse_VolumeStatus) ProtoMessage() {}

func (x *ControllerGetVolumeResponse_VolumeStatus) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[107]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerGetVolumeResponse_VolumeStatus.ProtoReflect.Descriptor instead.
func (*ControllerGetVolumeResponse_VolumeStatus) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{26, 0}
}

func (x *ControllerGetVolumeResponse_VolumeStatus) GetPublishedNodeIds() []string {
	if x != nil {
		return x.PublishedNodeIds
	}
	return nil
}

func (x *ControllerGetVolumeResponse_VolumeStatus) GetVolumeCondition() *VolumeCondition {
	if x != nil {
		return x.VolumeCondition
	}
	return nil
}

type ControllerServiceCapability_RPC struct {
	state         protoimpl.MessageState               `protogen:"open.v1"`
	Type          ControllerServiceCapability_RPC_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.ControllerServiceCapability_RPC_Type" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControllerServiceCapability_RPC) Reset() {
	*x = ControllerServiceCapability_RPC{}
	mi := &file_csi_proto_msgTypes[111]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControllerServiceCapability_RPC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControllerServiceCapability_RPC) ProtoMessage() {}

func (x *ControllerServiceCapability_RPC) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[111]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControllerServiceCapability_RPC.ProtoReflect.Descriptor instead.
func (*ControllerServiceCapability_RPC) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{33, 0}
}

func (x *ControllerServiceCapability_RPC) GetType() ControllerServiceCapability_RPC_Type {
	if x != nil {
		return x.Type
	}
	return ControllerServiceCapability_RPC_UNKNOWN
}

type ListSnapshotsResponse_Entry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Snapshot      *Snapshot              `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSnapshotsResponse_Entry) Reset() {
	*x = ListSnapshotsResponse_Entry{}
	mi := &file_csi_proto_msgTypes[116]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSnapshotsResponse_Entry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSnapshotsResponse_Entry) ProtoMessage() {}

func (x *ListSnapshotsResponse_Entry) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[116]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSnapshotsResponse_Entry.ProtoReflect.Descriptor instead.
func (*ListSnapshotsResponse_Entry) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{40, 0}
}

func (x *ListSnapshotsResponse_Entry) GetSnapshot() *Snapshot {
	if x != nil {
		return x.Snapshot
	}
	return nil
}

type NodeServiceCapability_RPC struct {
	state         protoimpl.MessageState         `protogen:"open.v1"`
	Type          NodeServiceCapability_RPC_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.NodeServiceCapability_RPC_Type" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeServiceCapability_RPC) Reset() {
	*x = NodeServiceCapability_RPC{}
	mi := &file_csi_proto_msgTypes[125]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeServiceCapability_RPC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeServiceCapability_RPC) ProtoMessage() {}

func (x *NodeServiceCapability_RPC) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[125]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeServiceCapability_RPC.ProtoReflect.Descriptor instead.
func (*NodeServiceCapability_RPC) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{59, 0}
}

func (x *NodeServiceCapability_RPC) GetType() NodeServiceCapability_RPC_Type {
	if x != nil {
		return x.Type
	}
	return NodeServiceCapability_RPC_UNKNOWN
}

type GroupControllerServiceCapability_RPC struct {
	state         protoimpl.MessageState                    `protogen:"open.v1"`
	Type          GroupControllerServiceCapability_RPC_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.GroupControllerServiceCapability_RPC_Type" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GroupControllerServiceCapability_RPC) Reset() {
	*x = GroupControllerServiceCapability_RPC{}
	mi := &file_csi_proto_msgTypes[127]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GroupControllerServiceCapability_RPC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GroupControllerServiceCapability_RPC) ProtoMessage() {}

func (x *GroupControllerServiceCapability_RPC) ProtoReflect() protoreflect.Message {
	mi := &file_csi_proto_msgTypes[127]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GroupControllerServiceCapability_RPC.ProtoReflect.Descriptor instead.
func (*GroupControllerServiceCapability_RPC) Descriptor() ([]byte, []int) {
	return file_csi_proto_rawDescGZIP(), []int{66, 0}
}

func (x *GroupControllerServiceCapability_RPC) GetType() GroupControllerServiceCapability_RPC_Type {
	if x != nil {
		return x.Type
	}
	return GroupControllerServiceCapability_RPC_UNKNOWN
}

var file_csi_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptor.EnumOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         1060,
		Name:          "csi.v1.alpha_enum",
		Tag:           "varint,1060,opt,name=alpha_enum",
		Filename:      "csi.proto",
	},
	{
		ExtendedType:  (*descriptor.EnumValueOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         1060,
		Name:          "csi.v1.alpha_enum_value",
		Tag:           "varint,1060,opt,name=alpha_enum_value",
		Filename:      "csi.proto",
	},
	{
		ExtendedType:  (*descriptor.FieldOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         1059,
		Name:          "csi.v1.csi_secret",
		Tag:           "varint,1059,opt,name=csi_secret",
		Filename:      "csi.proto",
	},
	{
		ExtendedType:  (*descriptor.FieldOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         1060,
		Name:          "csi.v1.alpha_field",
		Tag:           "varint,1060,opt,name=alpha_field",
		Filename:      "csi.proto",
	},
	{
		ExtendedType:  (*descriptor.MessageOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         1060,
		Name:          "csi.v1.alpha_message",
		Tag:           "varint,1060,opt,name=alpha_message",
		Filename:      "csi.proto",
	},
	{
		ExtendedType:  (*descriptor.MethodOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         1060,
		Name:          "csi.v1.alpha_method",
		Tag:           "varint,1060,opt,name=alpha_method",
		Filename:      "csi.proto",
	},
	{
		ExtendedType:  (*descriptor.ServiceOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         1060,
		Name:          "csi.v1.alpha_service",
		Tag:           "varint,1060,opt,name=alpha_service",
		Filename:      "csi.proto",
	},
}

// Extension fields to descriptor.EnumOptions.
var (
	// Indicates that this enum is OPTIONAL and part of an experimental
	// API that may be deprecated and eventually removed between minor
	// releases.
	//
	// optional bool alpha_enum = 1060;
	E_AlphaEnum = &file_csi_proto_extTypes[0]
)

// Extension fields to descriptor.EnumValueOptions.
var (
	// Indicates that this enum value is OPTIONAL and part of an
	// experimental API that may be deprecated and eventually removed
	// between minor releases.
	//
	// optional bool alpha_enum_value = 1060;
	E_AlphaEnumValue = &file_csi_proto_extTypes[1]
)

// Extension fields to descriptor.FieldOptions.
var (
	// Indicates that a field MAY contain information that is sensitive
	// and MUST be treated as such (e.g. not logged).
	//
	// optional bool csi_secret = 1059;
	E_CsiSecret = &file_csi_proto_extTypes[2]
	// Indicates that this field is OPTIONAL and part of an experimental
	// API that may be deprecated and eventually removed between minor
	// releases.
	//
	// optional bool alpha_field = 1060;
	E_AlphaField = &file_csi_proto_extTypes[3]
)

// Extension fields to descriptor.MessageOptions.
var (
	// Indicates that this message is OPTIONAL and part of an experimental
	// API that may be deprecated and eventually removed between minor
	// releases.
	//
	// optional bool alpha_message = 1060;
	E_AlphaMessage = &file_csi_proto_extTypes[4]
)

// Extension fields to descriptor.MethodOptions.
var (
	// Indicates that this method is OPTIONAL and part of an experimental
	// API that may be deprecated and eventually removed between minor
	// releases.
	//
	// optional bool alpha_method = 1060;
	E_AlphaMethod = &file_csi_proto_extTypes[5]
)

// Extension fields to descriptor.ServiceOptions.
var (
	// Indicates that this service is OPTIONAL and part of an experimental
	// API that may be deprecated and eventually removed between minor
	// releases.
	//
	// optional bool alpha_service = 1060;
	E_AlphaService = &file_csi_proto_extTypes[6]
)

var File_csi_proto protoreflect.FileDescriptor

const file_csi_proto_rawDesc = "" +
	"\n" +
	"\tcsi.proto\x12\x06csi.v1\x1a google/protobuf/descriptor.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\x16\n" +
	"\x14GetPluginInfoRequest\"\xd8\x01\n" +
	"\x15GetPluginInfoResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12%\n" +
	"\x0evendor_version\x18\x02 \x01(\tR\rvendorVersion\x12G\n" +
	"\bmanifest\x18\x03 \x03(\v2+.csi.v1.GetPluginInfoResponse.ManifestEntryR\bmanifest\x1a;\n" +
	"\rManifestEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x1e\n" +
	"\x1cGetPluginCapabilitiesRequest\"]\n" +
	"\x1dGetPluginCapabilitiesResponse\x12<\n" +
	"\fcapabilities\x18\x01 \x03(\v2\x18.csi.v1.PluginCapabilityR\fcapabilities\"\x91\x04\n" +
	"\x10PluginCapability\x12<\n" +
	"\aservice\x18\x01 \x01(\v2 .csi.v1.PluginCapability.ServiceH\x00R\aservice\x12U\n" +
	"\x10volume_expansion\x18\x02 \x01(\v2(.csi.v1.PluginCapability.VolumeExpansionH\x00R\x0fvolumeExpansion\x1a\xda\x01\n" +
	"\aService\x129\n" +
	"\x04type\x18\x01 \x01(\x0e2%.csi.v1.PluginCapability.Service.TypeR\x04type\"\x93\x01\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x16\n" +
	"\x12CONTROLLER_SERVICE\x10\x01\x12$\n" +
	" VOLUME_ACCESSIBILITY_CONSTRAINTS\x10\x02\x12\x1c\n" +
	"\x18GROUP_CONTROLLER_SERVICE\x10\x03\x12\"\n" +
	"\x19SNAPSHOT_METADATA_SERVICE\x10\x04\x1a\x03\xa0B\x01\x1a\x82\x01\n" +
	"\x0fVolumeExpansion\x12A\n" +
	"\x04type\x18\x01 \x01(\x0e2-.csi.v1.PluginCapability.VolumeExpansion.TypeR\x04type\",\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\n" +
	"\n" +
	"\x06ONLINE\x10\x01\x12\v\n" +
	"\aOFFLINE\x10\x02B\x06\n" +
	"\x04type\"\x0e\n" +
	"\fProbeRequest\"A\n" +
	"\rProbeResponse\x120\n" +
	"\x05ready\x18\x01 \x01(\v2\x1a.google.protobuf.BoolValueR\x05ready\"\x9e\x06\n" +
	"\x13CreateVolumeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12<\n" +
	"\x0ecapacity_range\x18\x02 \x01(\v2\x15.csi.v1.CapacityRangeR\rcapacityRange\x12I\n" +
	"\x13volume_capabilities\x18\x03 \x03(\v2\x18.csi.v1.VolumeCapabilityR\x12volumeCapabilities\x12K\n" +
	"\n" +
	"parameters\x18\x04 \x03(\v2+.csi.v1.CreateVolumeRequest.ParametersEntryR\n" +
	"parameters\x12G\n" +
	"\asecrets\x18\x05 \x03(\v2(.csi.v1.CreateVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12O\n" +
	"\x15volume_content_source\x18\x06 \x01(\v2\x1b.csi.v1.VolumeContentSourceR\x13volumeContentSource\x12Z\n" +
	"\x1aaccessibility_requirements\x18\a \x01(\v2\x1b.csi.v1.TopologyRequirementR\x19accessibilityRequirements\x12f\n" +
	"\x12mutable_parameters\x18\b \x03(\v22.csi.v1.CreateVolumeRequest.MutableParametersEntryB\x03\xa0B\x01R\x11mutableParameters\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aD\n" +
	"\x16MutableParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x8b\x02\n" +
	"\x13VolumeContentSource\x12H\n" +
	"\bsnapshot\x18\x01 \x01(\v2*.csi.v1.VolumeContentSource.SnapshotSourceH\x00R\bsnapshot\x12B\n" +
	"\x06volume\x18\x02 \x01(\v2(.csi.v1.VolumeContentSource.VolumeSourceH\x00R\x06volume\x1a1\n" +
	"\x0eSnapshotSource\x12\x1f\n" +
	"\vsnapshot_id\x18\x01 \x01(\tR\n" +
	"snapshotId\x1a+\n" +
	"\fVolumeSource\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeIdB\x06\n" +
	"\x04type\">\n" +
	"\x14CreateVolumeResponse\x12&\n" +
	"\x06volume\x18\x01 \x01(\v2\x0e.csi.v1.VolumeR\x06volume\"\x9f\x05\n" +
	"\x10VolumeCapability\x12<\n" +
	"\x05block\x18\x01 \x01(\v2$.csi.v1.VolumeCapability.BlockVolumeH\x00R\x05block\x12<\n" +
	"\x05mount\x18\x02 \x01(\v2$.csi.v1.VolumeCapability.MountVolumeH\x00R\x05mount\x12D\n" +
	"\vaccess_mode\x18\x03 \x01(\v2#.csi.v1.VolumeCapability.AccessModeR\n" +
	"accessMode\x1a\r\n" +
	"\vBlockVolume\x1au\n" +
	"\vMountVolume\x12\x17\n" +
	"\afs_type\x18\x01 \x01(\tR\x06fsType\x12\x1f\n" +
	"\vmount_flags\x18\x02 \x03(\tR\n" +
	"mountFlags\x12,\n" +
	"\x12volume_mount_group\x18\x03 \x01(\tR\x10volumeMountGroup\x1a\xb3\x02\n" +
	"\n" +
	"AccessMode\x12<\n" +
	"\x04mode\x18\x01 \x01(\x0e2(.csi.v1.VolumeCapability.AccessMode.ModeR\x04mode\"\xe6\x01\n" +
	"\x04Mode\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x16\n" +
	"\x12SINGLE_NODE_WRITER\x10\x01\x12\x1b\n" +
	"\x17SINGLE_NODE_READER_ONLY\x10\x02\x12\x1a\n" +
	"\x16MULTI_NODE_READER_ONLY\x10\x03\x12\x1c\n" +
	"\x18MULTI_NODE_SINGLE_WRITER\x10\x04\x12\x1b\n" +
	"\x17MULTI_NODE_MULTI_WRITER\x10\x05\x12\"\n" +
	"\x19SINGLE_NODE_SINGLE_WRITER\x10\x06\x1a\x03\xa0B\x01\x12!\n" +
	"\x18SINGLE_NODE_MULTI_WRITER\x10\a\x1a\x03\xa0B\x01B\r\n" +
	"\vaccess_type\"W\n" +
	"\rCapacityRange\x12%\n" +
	"\x0erequired_bytes\x18\x01 \x01(\x03R\rrequiredBytes\x12\x1f\n" +
	"\vlimit_bytes\x18\x02 \x01(\x03R\n" +
	"limitBytes\"\xdf\x02\n" +
	"\x06Volume\x12%\n" +
	"\x0ecapacity_bytes\x18\x01 \x01(\x03R\rcapacityBytes\x12\x1b\n" +
	"\tvolume_id\x18\x02 \x01(\tR\bvolumeId\x12H\n" +
	"\x0evolume_context\x18\x03 \x03(\v2!.csi.v1.Volume.VolumeContextEntryR\rvolumeContext\x12B\n" +
	"\x0econtent_source\x18\x04 \x01(\v2\x1b.csi.v1.VolumeContentSourceR\rcontentSource\x12A\n" +
	"\x13accessible_topology\x18\x05 \x03(\v2\x10.csi.v1.TopologyR\x12accessibleTopology\x1a@\n" +
	"\x12VolumeContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"u\n" +
	"\x13TopologyRequirement\x12.\n" +
	"\trequisite\x18\x01 \x03(\v2\x10.csi.v1.TopologyR\trequisite\x12.\n" +
	"\tpreferred\x18\x02 \x03(\v2\x10.csi.v1.TopologyR\tpreferred\"\x83\x01\n" +
	"\bTopology\x12:\n" +
	"\bsegments\x18\x01 \x03(\v2\x1e.csi.v1.Topology.SegmentsEntryR\bsegments\x1a;\n" +
	"\rSegmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb7\x01\n" +
	"\x13DeleteVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12G\n" +
	"\asecrets\x18\x02 \x03(\v2(.csi.v1.DeleteVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x16\n" +
	"\x14DeleteVolumeResponse\"\xed\x03\n" +
	"\x1eControllerPublishVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\x12E\n" +
	"\x11volume_capability\x18\x03 \x01(\v2\x18.csi.v1.VolumeCapabilityR\x10volumeCapability\x12\x1a\n" +
	"\breadonly\x18\x04 \x01(\bR\breadonly\x12R\n" +
	"\asecrets\x18\x05 \x03(\v23.csi.v1.ControllerPublishVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12`\n" +
	"\x0evolume_context\x18\x06 \x03(\v29.csi.v1.ControllerPublishVolumeRequest.VolumeContextEntryR\rvolumeContext\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a@\n" +
	"\x12VolumeContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xca\x01\n" +
	"\x1fControllerPublishVolumeResponse\x12d\n" +
	"\x0fpublish_context\x18\x01 \x03(\v2;.csi.v1.ControllerPublishVolumeResponse.PublishContextEntryR\x0epublishContext\x1aA\n" +
	"\x13PublishContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xea\x01\n" +
	" ControllerUnpublishVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12\x17\n" +
	"\anode_id\x18\x02 \x01(\tR\x06nodeId\x12T\n" +
	"\asecrets\x18\x03 \x03(\v25.csi.v1.ControllerUnpublishVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"#\n" +
	"!ControllerUnpublishVolumeResponse\"\x9b\x06\n" +
	"!ValidateVolumeCapabilitiesRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12c\n" +
	"\x0evolume_context\x18\x02 \x03(\v2<.csi.v1.ValidateVolumeCapabilitiesRequest.VolumeContextEntryR\rvolumeContext\x12I\n" +
	"\x13volume_capabilities\x18\x03 \x03(\v2\x18.csi.v1.VolumeCapabilityR\x12volumeCapabilities\x12Y\n" +
	"\n" +
	"parameters\x18\x04 \x03(\v29.csi.v1.ValidateVolumeCapabilitiesRequest.ParametersEntryR\n" +
	"parameters\x12U\n" +
	"\asecrets\x18\x05 \x03(\v26.csi.v1.ValidateVolumeCapabilitiesRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12t\n" +
	"\x12mutable_parameters\x18\x06 \x03(\v2@.csi.v1.ValidateVolumeCapabilitiesRequest.MutableParametersEntryB\x03\xa0B\x01R\x11mutableParameters\x1a@\n" +
	"\x12VolumeContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aD\n" +
	"\x16MutableParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x89\x06\n" +
	"\"ValidateVolumeCapabilitiesResponse\x12R\n" +
	"\tconfirmed\x18\x01 \x01(\v24.csi.v1.ValidateVolumeCapabilitiesResponse.ConfirmedR\tconfirmed\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x1a\xf4\x04\n" +
	"\tConfirmed\x12n\n" +
	"\x0evolume_context\x18\x01 \x03(\v2G.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.VolumeContextEntryR\rvolumeContext\x12I\n" +
	"\x13volume_capabilities\x18\x02 \x03(\v2\x18.csi.v1.VolumeCapabilityR\x12volumeCapabilities\x12d\n" +
	"\n" +
	"parameters\x18\x03 \x03(\v2D.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.ParametersEntryR\n" +
	"parameters\x12\x7f\n" +
	"\x12mutable_parameters\x18\x04 \x03(\v2K.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.MutableParametersEntryB\x03\xa0B\x01R\x11mutableParameters\x1a@\n" +
	"\x12VolumeContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aD\n" +
	"\x16MutableParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\\\n" +
	"\x12ListVolumesRequest\x12\x1f\n" +
	"\vmax_entries\x18\x01 \x01(\x05R\n" +
	"maxEntries\x12%\n" +
	"\x0estarting_token\x18\x02 \x01(\tR\rstartingToken\"\xec\x02\n" +
	"\x13ListVolumesResponse\x12;\n" +
	"\aentries\x18\x01 \x03(\v2!.csi.v1.ListVolumesResponse.EntryR\aentries\x12\x1d\n" +
	"\n" +
	"next_token\x18\x02 \x01(\tR\tnextToken\x1a\x85\x01\n" +
	"\fVolumeStatus\x12,\n" +
	"\x12published_node_ids\x18\x01 \x03(\tR\x10publishedNodeIds\x12G\n" +
	"\x10volume_condition\x18\x02 \x01(\v2\x17.csi.v1.VolumeConditionB\x03\xa0B\x01R\x0fvolumeCondition\x1aq\n" +
	"\x05Entry\x12&\n" +
	"\x06volume\x18\x01 \x01(\v2\x0e.csi.v1.VolumeR\x06volume\x12@\n" +
	"\x06status\x18\x02 \x01(\v2(.csi.v1.ListVolumesResponse.VolumeStatusR\x06status\">\n" +
	"\x1aControllerGetVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId:\x03\xa0B\x01\"\x97\x02\n" +
	"\x1bControllerGetVolumeResponse\x12&\n" +
	"\x06volume\x18\x01 \x01(\v2\x0e.csi.v1.VolumeR\x06volume\x12H\n" +
	"\x06status\x18\x02 \x01(\v20.csi.v1.ControllerGetVolumeResponse.VolumeStatusR\x06status\x1a\x80\x01\n" +
	"\fVolumeStatus\x12,\n" +
	"\x12published_node_ids\x18\x01 \x03(\tR\x10publishedNodeIds\x12B\n" +
	"\x10volume_condition\x18\x02 \x01(\v2\x17.csi.v1.VolumeConditionR\x0fvolumeCondition:\x03\xa0B\x01\"\x83\x03\n" +
	"\x1dControllerModifyVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12Q\n" +
	"\asecrets\x18\x02 \x03(\v22.csi.v1.ControllerModifyVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12k\n" +
	"\x12mutable_parameters\x18\x03 \x03(\v2<.csi.v1.ControllerModifyVolumeRequest.MutableParametersEntryR\x11mutableParameters\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aD\n" +
	"\x16MutableParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01:\x03\xa0B\x01\"%\n" +
	"\x1eControllerModifyVolumeResponse:\x03\xa0B\x01\"\xad\x02\n" +
	"\x12GetCapacityRequest\x12I\n" +
	"\x13volume_capabilities\x18\x01 \x03(\v2\x18.csi.v1.VolumeCapabilityR\x12volumeCapabilities\x12J\n" +
	"\n" +
	"parameters\x18\x02 \x03(\v2*.csi.v1.GetCapacityRequest.ParametersEntryR\n" +
	"parameters\x12A\n" +
	"\x13accessible_topology\x18\x03 \x01(\v2\x10.csi.v1.TopologyR\x12accessibleTopology\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe3\x01\n" +
	"\x13GetCapacityResponse\x12-\n" +
	"\x12available_capacity\x18\x01 \x01(\x03R\x11availableCapacity\x12K\n" +
	"\x13maximum_volume_size\x18\x02 \x01(\v2\x1b.google.protobuf.Int64ValueR\x11maximumVolumeSize\x12P\n" +
	"\x13minimum_volume_size\x18\x03 \x01(\v2\x1b.google.protobuf.Int64ValueB\x03\xa0B\x01R\x11minimumVolumeSize\"\"\n" +
	" ControllerGetCapabilitiesRequest\"l\n" +
	"!ControllerGetCapabilitiesResponse\x12G\n" +
	"\fcapabilities\x18\x01 \x03(\v2#.csi.v1.ControllerServiceCapabilityR\fcapabilities\"\xad\x04\n" +
	"\x1bControllerServiceCapability\x12;\n" +
	"\x03rpc\x18\x01 \x01(\v2'.csi.v1.ControllerServiceCapability.RPCH\x00R\x03rpc\x1a\xc8\x03\n" +
	"\x03RPC\x12@\n" +
	"\x04type\x18\x01 \x01(\x0e2,.csi.v1.ControllerServiceCapability.RPC.TypeR\x04type\"\xfe\x02\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x18\n" +
	"\x14CREATE_DELETE_VOLUME\x10\x01\x12\x1c\n" +
	"\x18PUBLISH_UNPUBLISH_VOLUME\x10\x02\x12\x10\n" +
	"\fLIST_VOLUMES\x10\x03\x12\x10\n" +
	"\fGET_CAPACITY\x10\x04\x12\x1a\n" +
	"\x16CREATE_DELETE_SNAPSHOT\x10\x05\x12\x12\n" +
	"\x0eLIST_SNAPSHOTS\x10\x06\x12\x10\n" +
	"\fCLONE_VOLUME\x10\a\x12\x14\n" +
	"\x10PUBLISH_READONLY\x10\b\x12\x11\n" +
	"\rEXPAND_VOLUME\x10\t\x12 \n" +
	"\x1cLIST_VOLUMES_PUBLISHED_NODES\x10\n" +
	"\x12\x19\n" +
	"\x10VOLUME_CONDITION\x10\v\x1a\x03\xa0B\x01\x12\x13\n" +
	"\n" +
	"GET_VOLUME\x10\f\x1a\x03\xa0B\x01\x12!\n" +
	"\x18SINGLE_NODE_MULTI_WRITER\x10\r\x1a\x03\xa0B\x01\x12\x16\n" +
	"\rMODIFY_VOLUME\x10\x0e\x1a\x03\xa0B\x01\x12\x15\n" +
	"\fGET_SNAPSHOT\x10\x0f\x1a\x03\xa0B\x01B\x06\n" +
	"\x04type\"\xea\x02\n" +
	"\x15CreateSnapshotRequest\x12(\n" +
	"\x10source_volume_id\x18\x01 \x01(\tR\x0esourceVolumeId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12I\n" +
	"\asecrets\x18\x03 \x03(\v2*.csi.v1.CreateSnapshotRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12M\n" +
	"\n" +
	"parameters\x18\x04 \x03(\v2-.csi.v1.CreateSnapshotRequest.ParametersEntryR\n" +
	"parameters\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"F\n" +
	"\x16CreateSnapshotResponse\x12,\n" +
	"\bsnapshot\x18\x01 \x01(\v2\x10.csi.v1.SnapshotR\bsnapshot\"\x83\x02\n" +
	"\bSnapshot\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x01 \x01(\x03R\tsizeBytes\x12\x1f\n" +
	"\vsnapshot_id\x18\x02 \x01(\tR\n" +
	"snapshotId\x12(\n" +
	"\x10source_volume_id\x18\x03 \x01(\tR\x0esourceVolumeId\x12?\n" +
	"\rcreation_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\fcreationTime\x12 \n" +
	"\fready_to_use\x18\x05 \x01(\bR\n" +
	"readyToUse\x12*\n" +
	"\x11group_snapshot_id\x18\x06 \x01(\tR\x0fgroupSnapshotId\"\xbf\x01\n" +
	"\x15DeleteSnapshotRequest\x12\x1f\n" +
	"\vsnapshot_id\x18\x01 \x01(\tR\n" +
	"snapshotId\x12I\n" +
	"\asecrets\x18\x02 \x03(\v2*.csi.v1.DeleteSnapshotRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x18\n" +
	"\x16DeleteSnapshotResponse\"\xaf\x02\n" +
	"\x14ListSnapshotsRequest\x12\x1f\n" +
	"\vmax_entries\x18\x01 \x01(\x05R\n" +
	"maxEntries\x12%\n" +
	"\x0estarting_token\x18\x02 \x01(\tR\rstartingToken\x12(\n" +
	"\x10source_volume_id\x18\x03 \x01(\tR\x0esourceVolumeId\x12\x1f\n" +
	"\vsnapshot_id\x18\x04 \x01(\tR\n" +
	"snapshotId\x12H\n" +
	"\asecrets\x18\x05 \x03(\v2).csi.v1.ListSnapshotsRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xac\x01\n" +
	"\x15ListSnapshotsResponse\x12=\n" +
	"\aentries\x18\x01 \x03(\v2#.csi.v1.ListSnapshotsResponse.EntryR\aentries\x12\x1d\n" +
	"\n" +
	"next_token\x18\x02 \x01(\tR\tnextToken\x1a5\n" +
	"\x05Entry\x12,\n" +
	"\bsnapshot\x18\x01 \x01(\v2\x10.csi.v1.SnapshotR\bsnapshot\"\xbe\x01\n" +
	"\x12GetSnapshotRequest\x12\x1f\n" +
	"\vsnapshot_id\x18\x01 \x01(\tR\n" +
	"snapshotId\x12F\n" +
	"\asecrets\x18\x02 \x03(\v2'.csi.v1.GetSnapshotRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01:\x03\xa0B\x01\"H\n" +
	"\x13GetSnapshotResponse\x12,\n" +
	"\bsnapshot\x18\x01 \x01(\v2\x10.csi.v1.SnapshotR\bsnapshot:\x03\xa0B\x01\"\xd0\x02\n" +
	"\x1dControllerExpandVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12<\n" +
	"\x0ecapacity_range\x18\x02 \x01(\v2\x15.csi.v1.CapacityRangeR\rcapacityRange\x12Q\n" +
	"\asecrets\x18\x03 \x03(\v22.csi.v1.ControllerExpandVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12E\n" +
	"\x11volume_capability\x18\x04 \x01(\v2\x18.csi.v1.VolumeCapabilityR\x10volumeCapability\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x7f\n" +
	"\x1eControllerExpandVolumeResponse\x12%\n" +
	"\x0ecapacity_bytes\x18\x01 \x01(\x03R\rcapacityBytes\x126\n" +
	"\x17node_expansion_required\x18\x02 \x01(\bR\x15nodeExpansionRequired\"\xf0\x04\n" +
	"\x16NodeStageVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12[\n" +
	"\x0fpublish_context\x18\x02 \x03(\v22.csi.v1.NodeStageVolumeRequest.PublishContextEntryR\x0epublishContext\x12.\n" +
	"\x13staging_target_path\x18\x03 \x01(\tR\x11stagingTargetPath\x12E\n" +
	"\x11volume_capability\x18\x04 \x01(\v2\x18.csi.v1.VolumeCapabilityR\x10volumeCapability\x12J\n" +
	"\asecrets\x18\x05 \x03(\v2+.csi.v1.NodeStageVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12X\n" +
	"\x0evolume_context\x18\x06 \x03(\v21.csi.v1.NodeStageVolumeRequest.VolumeContextEntryR\rvolumeContext\x1aA\n" +
	"\x13PublishContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a@\n" +
	"\x12VolumeContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x19\n" +
	"\x17NodeStageVolumeResponse\"g\n" +
	"\x18NodeUnstageVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12.\n" +
	"\x13staging_target_path\x18\x02 \x01(\tR\x11stagingTargetPath\"\x1b\n" +
	"\x19NodeUnstageVolumeResponse\"\xb5\x05\n" +
	"\x18NodePublishVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12]\n" +
	"\x0fpublish_context\x18\x02 \x03(\v24.csi.v1.NodePublishVolumeRequest.PublishContextEntryR\x0epublishContext\x12.\n" +
	"\x13staging_target_path\x18\x03 \x01(\tR\x11stagingTargetPath\x12\x1f\n" +
	"\vtarget_path\x18\x04 \x01(\tR\n" +
	"targetPath\x12E\n" +
	"\x11volume_capability\x18\x05 \x01(\v2\x18.csi.v1.VolumeCapabilityR\x10volumeCapability\x12\x1a\n" +
	"\breadonly\x18\x06 \x01(\bR\breadonly\x12L\n" +
	"\asecrets\x18\a \x03(\v2-.csi.v1.NodePublishVolumeRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12Z\n" +
	"\x0evolume_context\x18\b \x03(\v23.csi.v1.NodePublishVolumeRequest.VolumeContextEntryR\rvolumeContext\x1aA\n" +
	"\x13PublishContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a@\n" +
	"\x12VolumeContextEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x1b\n" +
	"\x19NodePublishVolumeResponse\"Z\n" +
	"\x1aNodeUnpublishVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12\x1f\n" +
	"\vtarget_path\x18\x02 \x01(\tR\n" +
	"targetPath\"\x1d\n" +
	"\x1bNodeUnpublishVolumeResponse\"\x89\x01\n" +
	"\x19NodeGetVolumeStatsRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12\x1f\n" +
	"\vvolume_path\x18\x02 \x01(\tR\n" +
	"volumePath\x12.\n" +
	"\x13staging_target_path\x18\x03 \x01(\tR\x11stagingTargetPath\"\x90\x01\n" +
	"\x1aNodeGetVolumeStatsResponse\x12)\n" +
	"\x05usage\x18\x01 \x03(\v2\x13.csi.v1.VolumeUsageR\x05usage\x12G\n" +
	"\x10volume_condition\x18\x02 \x01(\v2\x17.csi.v1.VolumeConditionB\x03\xa0B\x01R\x0fvolumeCondition\"\xaf\x01\n" +
	"\vVolumeUsage\x12\x1c\n" +
	"\tavailable\x18\x01 \x01(\x03R\tavailable\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x03R\x05total\x12\x12\n" +
	"\x04used\x18\x03 \x01(\x03R\x04used\x12,\n" +
	"\x04unit\x18\x04 \x01(\x0e2\x18.csi.v1.VolumeUsage.UnitR\x04unit\"*\n" +
	"\x04Unit\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\t\n" +
	"\x05BYTES\x10\x01\x12\n" +
	"\n" +
	"\x06INODES\x10\x02\"L\n" +
	"\x0fVolumeCondition\x12\x1a\n" +
	"\babnormal\x18\x01 \x01(\bR\babnormal\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage:\x03\xa0B\x01\"\x1c\n" +
	"\x1aNodeGetCapabilitiesRequest\"`\n" +
	"\x1bNodeGetCapabilitiesResponse\x12A\n" +
	"\fcapabilities\x18\x01 \x03(\v2\x1d.csi.v1.NodeServiceCapabilityR\fcapabilities\"\xc9\x02\n" +
	"\x15NodeServiceCapability\x125\n" +
	"\x03rpc\x18\x01 \x01(\v2!.csi.v1.NodeServiceCapability.RPCH\x00R\x03rpc\x1a\xf0\x01\n" +
	"\x03RPC\x12:\n" +
	"\x04type\x18\x01 \x01(\x0e2&.csi.v1.NodeServiceCapability.RPC.TypeR\x04type\"\xac\x01\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x18\n" +
	"\x14STAGE_UNSTAGE_VOLUME\x10\x01\x12\x14\n" +
	"\x10GET_VOLUME_STATS\x10\x02\x12\x11\n" +
	"\rEXPAND_VOLUME\x10\x03\x12\x19\n" +
	"\x10VOLUME_CONDITION\x10\x04\x1a\x03\xa0B\x01\x12!\n" +
	"\x18SINGLE_NODE_MULTI_WRITER\x10\x05\x1a\x03\xa0B\x01\x12\x16\n" +
	"\x12VOLUME_MOUNT_GROUP\x10\x06B\x06\n" +
	"\x04type\"\x14\n" +
	"\x12NodeGetInfoRequest\"\xa2\x01\n" +
	"\x13NodeGetInfoResponse\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12/\n" +
	"\x14max_volumes_per_node\x18\x02 \x01(\x03R\x11maxVolumesPerNode\x12A\n" +
	"\x13accessible_topology\x18\x03 \x01(\v2\x10.csi.v1.TopologyR\x12accessibleTopology\"\x98\x03\n" +
	"\x17NodeExpandVolumeRequest\x12\x1b\n" +
	"\tvolume_id\x18\x01 \x01(\tR\bvolumeId\x12\x1f\n" +
	"\vvolume_path\x18\x02 \x01(\tR\n" +
	"volumePath\x12<\n" +
	"\x0ecapacity_range\x18\x03 \x01(\v2\x15.csi.v1.CapacityRangeR\rcapacityRange\x12.\n" +
	"\x13staging_target_path\x18\x04 \x01(\tR\x11stagingTargetPath\x12E\n" +
	"\x11volume_capability\x18\x05 \x01(\v2\x18.csi.v1.VolumeCapabilityR\x10volumeCapability\x12N\n" +
	"\asecrets\x18\x06 \x03(\v2,.csi.v1.NodeExpandVolumeRequest.SecretsEntryB\x06\x98B\x01\xa0B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"A\n" +
	"\x18NodeExpandVolumeResponse\x12%\n" +
	"\x0ecapacity_bytes\x18\x01 \x01(\x03R\rcapacityBytes\"'\n" +
	"%GroupControllerGetCapabilitiesRequest\"v\n" +
	"&GroupControllerGetCapabilitiesResponse\x12L\n" +
	"\fcapabilities\x18\x01 \x03(\v2(.csi.v1.GroupControllerServiceCapabilityR\fcapabilities\"\xfd\x01\n" +
	" GroupControllerServiceCapability\x12@\n" +
	"\x03rpc\x18\x01 \x01(\v2,.csi.v1.GroupControllerServiceCapability.RPCH\x00R\x03rpc\x1a\x8e\x01\n" +
	"\x03RPC\x12E\n" +
	"\x04type\x18\x01 \x01(\x0e21.csi.v1.GroupControllerServiceCapability.RPC.TypeR\x04type\"@\n" +
	"\x04Type\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12+\n" +
	"'CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT\x10\x01B\x06\n" +
	"\x04type\"\x8d\x03\n" +
	" CreateVolumeGroupSnapshotRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12*\n" +
	"\x11source_volume_ids\x18\x02 \x03(\tR\x0fsourceVolumeIds\x12T\n" +
	"\asecrets\x18\x03 \x03(\v25.csi.v1.CreateVolumeGroupSnapshotRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x12X\n" +
	"\n" +
	"parameters\x18\x04 \x03(\v28.csi.v1.CreateVolumeGroupSnapshotRequest.ParametersEntryR\n" +
	"parameters\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a=\n" +
	"\x0fParametersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"g\n" +
	"!CreateVolumeGroupSnapshotResponse\x12B\n" +
	"\x0egroup_snapshot\x18\x01 \x01(\v2\x1b.csi.v1.VolumeGroupSnapshotR\rgroupSnapshot\"\xd4\x01\n" +
	"\x13VolumeGroupSnapshot\x12*\n" +
	"\x11group_snapshot_id\x18\x01 \x01(\tR\x0fgroupSnapshotId\x12.\n" +
	"\tsnapshots\x18\x02 \x03(\v2\x10.csi.v1.SnapshotR\tsnapshots\x12?\n" +
	"\rcreation_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\fcreationTime\x12 \n" +
	"\fready_to_use\x18\x04 \x01(\bR\n" +
	"readyToUse\"\x83\x02\n" +
	" DeleteVolumeGroupSnapshotRequest\x12*\n" +
	"\x11group_snapshot_id\x18\x01 \x01(\tR\x0fgroupSnapshotId\x12!\n" +
	"\fsnapshot_ids\x18\x02 \x03(\tR\vsnapshotIds\x12T\n" +
	"\asecrets\x18\x03 \x03(\v25.csi.v1.DeleteVolumeGroupSnapshotRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"#\n" +
	"!DeleteVolumeGroupSnapshotResponse\"\xfd\x01\n" +
	"\x1dGetVolumeGroupSnapshotRequest\x12*\n" +
	"\x11group_snapshot_id\x18\x01 \x01(\tR\x0fgroupSnapshotId\x12!\n" +
	"\fsnapshot_ids\x18\x02 \x03(\tR\vsnapshotIds\x12Q\n" +
	"\asecrets\x18\x03 \x03(\v22.csi.v1.GetVolumeGroupSnapshotRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"d\n" +
	"\x1eGetVolumeGroupSnapshotResponse\x12B\n" +
	"\x0egroup_snapshot\x18\x01 \x01(\v2\x1b.csi.v1.VolumeGroupSnapshotR\rgroupSnapshot\"O\n" +
	"\rBlockMetadata\x12\x1f\n" +
	"\vbyte_offset\x18\x01 \x01(\x03R\n" +
	"byteOffset\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x02 \x01(\x03R\tsizeBytes\"\x95\x02\n" +
	"\x1bGetMetadataAllocatedRequest\x12\x1f\n" +
	"\vsnapshot_id\x18\x01 \x01(\tR\n" +
	"snapshotId\x12'\n" +
	"\x0fstarting_offset\x18\x02 \x01(\x03R\x0estartingOffset\x12\x1f\n" +
	"\vmax_results\x18\x03 \x01(\x05R\n" +
	"maxResults\x12O\n" +
	"\asecrets\x18\x04 \x03(\v20.csi.v1.GetMetadataAllocatedRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xdb\x01\n" +
	"\x1cGetMetadataAllocatedResponse\x12I\n" +
	"\x13block_metadata_type\x18\x01 \x01(\x0e2\x19.csi.v1.BlockMetadataTypeR\x11blockMetadataType\x122\n" +
	"\x15volume_capacity_bytes\x18\x02 \x01(\x03R\x13volumeCapacityBytes\x12<\n" +
	"\x0eblock_metadata\x18\x03 \x03(\v2\x15.csi.v1.BlockMetadataR\rblockMetadata\"\xc4\x02\n" +
	"\x17GetMetadataDeltaRequest\x12(\n" +
	"\x10base_snapshot_id\x18\x01 \x01(\tR\x0ebaseSnapshotId\x12,\n" +
	"\x12target_snapshot_id\x18\x02 \x01(\tR\x10targetSnapshotId\x12'\n" +
	"\x0fstarting_offset\x18\x03 \x01(\x03R\x0estartingOffset\x12\x1f\n" +
	"\vmax_results\x18\x04 \x01(\x05R\n" +
	"maxResults\x12K\n" +
	"\asecrets\x18\x05 \x03(\v2,.csi.v1.GetMetadataDeltaRequest.SecretsEntryB\x03\x98B\x01R\asecrets\x1a:\n" +
	"\fSecretsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xd7\x01\n" +
	"\x18GetMetadataDeltaResponse\x12I\n" +
	"\x13block_metadata_type\x18\x01 \x01(\x0e2\x19.csi.v1.BlockMetadataTypeR\x11blockMetadataType\x122\n" +
	"\x15volume_capacity_bytes\x18\x02 \x01(\x03R\x13volumeCapacityBytes\x12<\n" +
	"\x0eblock_metadata\x18\x03 \x03(\v2\x15.csi.v1.BlockMetadataR\rblockMetadata*G\n" +
	"\x11BlockMetadataType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x10\n" +
	"\fFIXED_LENGTH\x10\x01\x12\x13\n" +
	"\x0fVARIABLE_LENGTH\x10\x022\xfa\x01\n" +
	"\bIdentity\x12N\n" +
	"\rGetPluginInfo\x12\x1c.csi.v1.GetPluginInfoRequest\x1a\x1d.csi.v1.GetPluginInfoResponse\"\x00\x12f\n" +
	"\x15GetPluginCapabilities\x12$.csi.v1.GetPluginCapabilitiesRequest\x1a%.csi.v1.GetPluginCapabilitiesResponse\"\x00\x126\n" +
	"\x05Probe\x12\x14.csi.v1.ProbeRequest\x1a\x15.csi.v1.ProbeResponse\"\x002\x88\v\n" +
	"\n" +
	"Controller\x12K\n" +
	"\fCreateVolume\x12\x1b.csi.v1.CreateVolumeRequest\x1a\x1c.csi.v1.CreateVolumeResponse\"\x00\x12K\n" +
	"\fDeleteVolume\x12\x1b.csi.v1.DeleteVolumeRequest\x1a\x1c.csi.v1.DeleteVolumeResponse\"\x00\x12l\n" +
	"\x17ControllerPublishVolume\x12&.csi.v1.ControllerPublishVolumeRequest\x1a'.csi.v1.ControllerPublishVolumeResponse\"\x00\x12r\n" +
	"\x19ControllerUnpublishVolume\x12(.csi.v1.ControllerUnpublishVolumeRequest\x1a).csi.v1.ControllerUnpublishVolumeResponse\"\x00\x12u\n" +
	"\x1aValidateVolumeCapabilities\x12).csi.v1.ValidateVolumeCapabilitiesRequest\x1a*.csi.v1.ValidateVolumeCapabilitiesResponse\"\x00\x12H\n" +
	"\vListVolumes\x12\x1a.csi.v1.ListVolumesRequest\x1a\x1b.csi.v1.ListVolumesResponse\"\x00\x12H\n" +
	"\vGetCapacity\x12\x1a.csi.v1.GetCapacityRequest\x1a\x1b.csi.v1.GetCapacityResponse\"\x00\x12r\n" +
	"\x19ControllerGetCapabilities\x12(.csi.v1.ControllerGetCapabilitiesRequest\x1a).csi.v1.ControllerGetCapabilitiesResponse\"\x00\x12Q\n" +
	"\x0eCreateSnapshot\x12\x1d.csi.v1.CreateSnapshotRequest\x1a\x1e.csi.v1.CreateSnapshotResponse\"\x00\x12Q\n" +
	"\x0eDeleteSnapshot\x12\x1d.csi.v1.DeleteSnapshotRequest\x1a\x1e.csi.v1.DeleteSnapshotResponse\"\x00\x12N\n" +
	"\rListSnapshots\x12\x1c.csi.v1.ListSnapshotsRequest\x1a\x1d.csi.v1.ListSnapshotsResponse\"\x00\x12K\n" +
	"\vGetSnapshot\x12\x1a.csi.v1.GetSnapshotRequest\x1a\x1b.csi.v1.GetSnapshotResponse\"\x03\xa0B\x01\x12i\n" +
	"\x16ControllerExpandVolume\x12%.csi.v1.ControllerExpandVolumeRequest\x1a&.csi.v1.ControllerExpandVolumeResponse\"\x00\x12c\n" +
	"\x13ControllerGetVolume\x12\".csi.v1.ControllerGetVolumeRequest\x1a#.csi.v1.ControllerGetVolumeResponse\"\x03\xa0B\x01\x12l\n" +
	"\x16ControllerModifyVolume\x12%.csi.v1.ControllerModifyVolumeRequest\x1a&.csi.v1.ControllerModifyVolumeResponse\"\x03\xa0B\x012\xe8\x03\n" +
	"\x0fGroupController\x12\x81\x01\n" +
	"\x1eGroupControllerGetCapabilities\x12-.csi.v1.GroupControllerGetCapabilitiesRequest\x1a..csi.v1.GroupControllerGetCapabilitiesResponse\"\x00\x12r\n" +
	"\x19CreateVolumeGroupSnapshot\x12(.csi.v1.CreateVolumeGroupSnapshotRequest\x1a).csi.v1.CreateVolumeGroupSnapshotResponse\"\x00\x12r\n" +
	"\x19DeleteVolumeGroupSnapshot\x12(.csi.v1.DeleteVolumeGroupSnapshotRequest\x1a).csi.v1.DeleteVolumeGroupSnapshotResponse\"\x00\x12i\n" +
	"\x16GetVolumeGroupSnapshot\x12%.csi.v1.GetVolumeGroupSnapshotRequest\x1a&.csi.v1.GetVolumeGroupSnapshotResponse\"\x002\xd9\x01\n" +
	"\x10SnapshotMetadata\x12e\n" +
	"\x14GetMetadataAllocated\x12#.csi.v1.GetMetadataAllocatedRequest\x1a$.csi.v1.GetMetadataAllocatedResponse\"\x000\x01\x12Y\n" +
	"\x10GetMetadataDelta\x12\x1f.csi.v1.GetMetadataDeltaRequest\x1a .csi.v1.GetMetadataDeltaResponse\"\x000\x01\x1a\x03\xa0B\x012\xda\x05\n" +
	"\x04Node\x12T\n" +
	"\x0fNodeStageVolume\x12\x1e.csi.v1.NodeStageVolumeRequest\x1a\x1f.csi.v1.NodeStageVolumeResponse\"\x00\x12Z\n" +
	"\x11NodeUnstageVolume\x12 .csi.v1.NodeUnstageVolumeRequest\x1a!.csi.v1.NodeUnstageVolumeResponse\"\x00\x12Z\n" +
	"\x11NodePublishVolume\x12 .csi.v1.NodePublishVolumeRequest\x1a!.csi.v1.NodePublishVolumeResponse\"\x00\x12`\n" +
	"\x13NodeUnpublishVolume\x12\".csi.v1.NodeUnpublishVolumeRequest\x1a#.csi.v1.NodeUnpublishVolumeResponse\"\x00\x12]\n" +
	"\x12NodeGetVolumeStats\x12!.csi.v1.NodeGetVolumeStatsRequest\x1a\".csi.v1.NodeGetVolumeStatsResponse\"\x00\x12W\n" +
	"\x10NodeExpandVolume\x12\x1f.csi.v1.NodeExpandVolumeRequest\x1a .csi.v1.NodeExpandVolumeResponse\"\x00\x12`\n" +
	"\x13NodeGetCapabilities\x12\".csi.v1.NodeGetCapabilitiesRequest\x1a#.csi.v1.NodeGetCapabilitiesResponse\"\x00\x12H\n" +
	"\vNodeGetInfo\x12\x1a.csi.v1.NodeGetInfoRequest\x1a\x1b.csi.v1.NodeGetInfoResponse\"\x00:<\n" +
	"\n" +
	"alpha_enum\x12\x1c.google.protobuf.EnumOptions\x18\xa4\b \x01(\bR\talphaEnum:L\n" +
	"\x10alpha_enum_value\x12!.google.protobuf.EnumValueOptions\x18\xa4\b \x01(\bR\x0ealphaEnumValue:=\n" +
	"\n" +
	"csi_secret\x12\x1d.google.protobuf.FieldOptions\x18\xa3\b \x01(\bR\tcsiSecret:?\n" +
	"\valpha_field\x12\x1d.google.protobuf.FieldOptions\x18\xa4\b \x01(\bR\n" +
	"alphaField:E\n" +
	"\ralpha_message\x12\x1f.google.protobuf.MessageOptions\x18\xa4\b \x01(\bR\falphaMessage:B\n" +
	"\falpha_method\x12\x1e.google.protobuf.MethodOptions\x18\xa4\b \x01(\bR\valphaMethod:E\n" +
	"\ralpha_service\x12\x1f.google.protobuf.ServiceOptions\x18\xa4\b \x01(\bR\falphaServiceB8Z6github.com/container-storage-interface/spec/lib/go/csib\x06proto3"

var (
	file_csi_proto_rawDescOnce sync.Once
	file_csi_proto_rawDescData []byte
)

func file_csi_proto_rawDescGZIP() []byte {
	file_csi_proto_rawDescOnce.Do(func() {
		file_csi_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_csi_proto_rawDesc), len(file_csi_proto_rawDesc)))
	})
	return file_csi_proto_rawDescData
}

var file_csi_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_csi_proto_msgTypes = make([]protoimpl.MessageInfo, 134)
var file_csi_proto_goTypes = []any{
	(BlockMetadataType)(0),                               // 0: csi.v1.BlockMetadataType
	(PluginCapability_Service_Type)(0),                   // 1: csi.v1.PluginCapability.Service.Type
	(PluginCapability_VolumeExpansion_Type)(0),           // 2: csi.v1.PluginCapability.VolumeExpansion.Type
	(VolumeCapability_AccessMode_Mode)(0),                // 3: csi.v1.VolumeCapability.AccessMode.Mode
	(ControllerServiceCapability_RPC_Type)(0),            // 4: csi.v1.ControllerServiceCapability.RPC.Type
	(VolumeUsage_Unit)(0),                                // 5: csi.v1.VolumeUsage.Unit
	(NodeServiceCapability_RPC_Type)(0),                  // 6: csi.v1.NodeServiceCapability.RPC.Type
	(GroupControllerServiceCapability_RPC_Type)(0),       // 7: csi.v1.GroupControllerServiceCapability.RPC.Type
	(*GetPluginInfoRequest)(nil),                         // 8: csi.v1.GetPluginInfoRequest
	(*GetPluginInfoResponse)(nil),                        // 9: csi.v1.GetPluginInfoResponse
	(*GetPluginCapabilitiesRequest)(nil),                 // 10: csi.v1.GetPluginCapabilitiesRequest
	(*GetPluginCapabilitiesResponse)(nil),                // 11: csi.v1.GetPluginCapabilitiesResponse
	(*PluginCapability)(nil),                             // 12: csi.v1.PluginCapability
	(*ProbeRequest)(nil),                                 // 13: csi.v1.ProbeRequest
	(*ProbeResponse)(nil),                                // 14: csi.v1.ProbeResponse
	(*CreateVolumeRequest)(nil),                          // 15: csi.v1.CreateVolumeRequest
	(*VolumeContentSource)(nil),                          // 16: csi.v1.VolumeContentSource
	(*CreateVolumeResponse)(nil),                         // 17: csi.v1.CreateVolumeResponse
	(*VolumeCapability)(nil),                             // 18: csi.v1.VolumeCapability
	(*CapacityRange)(nil),                                // 19: csi.v1.CapacityRange
	(*Volume)(nil),                                       // 20: csi.v1.Volume
	(*TopologyRequirement)(nil),                          // 21: csi.v1.TopologyRequirement
	(*Topology)(nil),                                     // 22: csi.v1.Topology
	(*DeleteVolumeRequest)(nil),                          // 23: csi.v1.DeleteVolumeRequest
	(*DeleteVolumeResponse)(nil),                         // 24: csi.v1.DeleteVolumeResponse
	(*ControllerPublishVolumeRequest)(nil),               // 25: csi.v1.ControllerPublishVolumeRequest
	(*ControllerPublishVolumeResponse)(nil),              // 26: csi.v1.ControllerPublishVolumeResponse
	(*ControllerUnpublishVolumeRequest)(nil),             // 27: csi.v1.ControllerUnpublishVolumeRequest
	(*ControllerUnpublishVolumeResponse)(nil),            // 28: csi.v1.ControllerUnpublishVolumeResponse
	(*ValidateVolumeCapabilitiesRequest)(nil),            // 29: csi.v1.ValidateVolumeCapabilitiesRequest
	(*ValidateVolumeCapabilitiesResponse)(nil),           // 30: csi.v1.ValidateVolumeCapabilitiesResponse
	(*ListVolumesRequest)(nil),                           // 31: csi.v1.ListVolumesRequest
	(*ListVolumesResponse)(nil),                          // 32: csi.v1.ListVolumesResponse
	(*ControllerGetVolumeRequest)(nil),                   // 33: csi.v1.ControllerGetVolumeRequest
	(*ControllerGetVolumeResponse)(nil),                  // 34: csi.v1.ControllerGetVolumeResponse
	(*ControllerModifyVolumeRequest)(nil),                // 35: csi.v1.ControllerModifyVolumeRequest
	(*ControllerModifyVolumeResponse)(nil),               // 36: csi.v1.ControllerModifyVolumeResponse
	(*GetCapacityRequest)(nil),                           // 37: csi.v1.GetCapacityRequest
	(*GetCapacityResponse)(nil),                          // 38: csi.v1.GetCapacityResponse
	(*ControllerGetCapabilitiesRequest)(nil),             // 39: csi.v1.ControllerGetCapabilitiesRequest
	(*ControllerGetCapabilitiesResponse)(nil),            // 40: csi.v1.ControllerGetCapabilitiesResponse
	(*ControllerServiceCapability)(nil),                  // 41: csi.v1.ControllerServiceCapability
	(*CreateSnapshotRequest)(nil),                        // 42: csi.v1.CreateSnapshotRequest
	(*CreateSnapshotResponse)(nil),                       // 43: csi.v1.CreateSnapshotResponse
	(*Snapshot)(nil),                                     // 44: csi.v1.Snapshot
	(*DeleteSnapshotRequest)(nil),                        // 45: csi.v1.DeleteSnapshotRequest
	(*DeleteSnapshotResponse)(nil),                       // 46: csi.v1.DeleteSnapshotResponse
	(*ListSnapshotsRequest)(nil),                         // 47: csi.v1.ListSnapshotsRequest
	(*ListSnapshotsResponse)(nil),                        // 48: csi.v1.ListSnapshotsResponse
	(*GetSnapshotRequest)(nil),                           // 49: csi.v1.GetSnapshotRequest
	(*GetSnapshotResponse)(nil),                          // 50: csi.v1.GetSnapshotResponse
	(*ControllerExpandVolumeRequest)(nil),                // 51: csi.v1.ControllerExpandVolumeRequest
	(*ControllerExpandVolumeResponse)(nil),               // 52: csi.v1.ControllerExpandVolumeResponse
	(*NodeStageVolumeRequest)(nil),                       // 53: csi.v1.NodeStageVolumeRequest
	(*NodeStageVolumeResponse)(nil),                      // 54: csi.v1.NodeStageVolumeResponse
	(*NodeUnstageVolumeRequest)(nil),                     // 55: csi.v1.NodeUnstageVolumeRequest
	(*NodeUnstageVolumeResponse)(nil),                    // 56: csi.v1.NodeUnstageVolumeResponse
	(*NodePublishVolumeRequest)(nil),                     // 57: csi.v1.NodePublishVolumeRequest
	(*NodePublishVolumeResponse)(nil),                    // 58: csi.v1.NodePublishVolumeResponse
	(*NodeUnpublishVolumeRequest)(nil),                   // 59: csi.v1.NodeUnpublishVolumeRequest
	(*NodeUnpublishVolumeResponse)(nil),                  // 60: csi.v1.NodeUnpublishVolumeResponse
	(*NodeGetVolumeStatsRequest)(nil),                    // 61: csi.v1.NodeGetVolumeStatsRequest
	(*NodeGetVolumeStatsResponse)(nil),                   // 62: csi.v1.NodeGetVolumeStatsResponse
	(*VolumeUsage)(nil),                                  // 63: csi.v1.VolumeUsage
	(*VolumeCondition)(nil),                              // 64: csi.v1.VolumeCondition
	(*NodeGetCapabilitiesRequest)(nil),                   // 65: csi.v1.NodeGetCapabilitiesRequest
	(*NodeGetCapabilitiesResponse)(nil),                  // 66: csi.v1.NodeGetCapabilitiesResponse
	(*NodeServiceCapability)(nil),                        // 67: csi.v1.NodeServiceCapability
	(*NodeGetInfoRequest)(nil),                           // 68: csi.v1.NodeGetInfoRequest
	(*NodeGetInfoResponse)(nil),                          // 69: csi.v1.NodeGetInfoResponse
	(*NodeExpandVolumeRequest)(nil),                      // 70: csi.v1.NodeExpandVolumeRequest
	(*NodeExpandVolumeResponse)(nil),                     // 71: csi.v1.NodeExpandVolumeResponse
	(*GroupControllerGetCapabilitiesRequest)(nil),        // 72: csi.v1.GroupControllerGetCapabilitiesRequest
	(*GroupControllerGetCapabilitiesResponse)(nil),       // 73: csi.v1.GroupControllerGetCapabilitiesResponse
	(*GroupControllerServiceCapability)(nil),             // 74: csi.v1.GroupControllerServiceCapability
	(*CreateVolumeGroupSnapshotRequest)(nil),             // 75: csi.v1.CreateVolumeGroupSnapshotRequest
	(*CreateVolumeGroupSnapshotResponse)(nil),            // 76: csi.v1.CreateVolumeGroupSnapshotResponse
	(*VolumeGroupSnapshot)(nil),                          // 77: csi.v1.VolumeGroupSnapshot
	(*DeleteVolumeGroupSnapshotRequest)(nil),             // 78: csi.v1.DeleteVolumeGroupSnapshotRequest
	(*DeleteVolumeGroupSnapshotResponse)(nil),            // 79: csi.v1.DeleteVolumeGroupSnapshotResponse
	(*GetVolumeGroupSnapshotRequest)(nil),                // 80: csi.v1.GetVolumeGroupSnapshotRequest
	(*GetVolumeGroupSnapshotResponse)(nil),               // 81: csi.v1.GetVolumeGroupSnapshotResponse
	(*BlockMetadata)(nil),                                // 82: csi.v1.BlockMetadata
	(*GetMetadataAllocatedRequest)(nil),                  // 83: csi.v1.GetMetadataAllocatedRequest
	(*GetMetadataAllocatedResponse)(nil),                 // 84: csi.v1.GetMetadataAllocatedResponse
	(*GetMetadataDeltaRequest)(nil),                      // 85: csi.v1.GetMetadataDeltaRequest
	(*GetMetadataDeltaResponse)(nil),                     // 86: csi.v1.GetMetadataDeltaResponse
	nil,                                                  // 87: csi.v1.GetPluginInfoResponse.ManifestEntry
	(*PluginCapability_Service)(nil),                     // 88: csi.v1.PluginCapability.Service
	(*PluginCapability_VolumeExpansion)(nil),             // 89: csi.v1.PluginCapability.VolumeExpansion
	nil,                                                  // 90: csi.v1.CreateVolumeRequest.ParametersEntry
	nil,                                                  // 91: csi.v1.CreateVolumeRequest.SecretsEntry
	nil,                                                  // 92: csi.v1.CreateVolumeRequest.MutableParametersEntry
	(*VolumeContentSource_SnapshotSource)(nil),           // 93: csi.v1.VolumeContentSource.SnapshotSource
	(*VolumeContentSource_VolumeSource)(nil),             // 94: csi.v1.VolumeContentSource.VolumeSource
	(*VolumeCapability_BlockVolume)(nil),                 // 95: csi.v1.VolumeCapability.BlockVolume
	(*VolumeCapability_MountVolume)(nil),                 // 96: csi.v1.VolumeCapability.MountVolume
	(*VolumeCapability_AccessMode)(nil),                  // 97: csi.v1.VolumeCapability.AccessMode
	nil,                                                  // 98: csi.v1.Volume.VolumeContextEntry
	nil,                                                  // 99: csi.v1.Topology.SegmentsEntry
	nil,                                                  // 100: csi.v1.DeleteVolumeRequest.SecretsEntry
	nil,                                                  // 101: csi.v1.ControllerPublishVolumeRequest.SecretsEntry
	nil,                                                  // 102: csi.v1.ControllerPublishVolumeRequest.VolumeContextEntry
	nil,                                                  // 103: csi.v1.ControllerPublishVolumeResponse.PublishContextEntry
	nil,                                                  // 104: csi.v1.ControllerUnpublishVolumeRequest.SecretsEntry
	nil,                                                  // 105: csi.v1.ValidateVolumeCapabilitiesRequest.VolumeContextEntry
	nil,                                                  // 106: csi.v1.ValidateVolumeCapabilitiesRequest.ParametersEntry
	nil,                                                  // 107: csi.v1.ValidateVolumeCapabilitiesRequest.SecretsEntry
	nil,                                                  // 108: csi.v1.ValidateVolumeCapabilitiesRequest.MutableParametersEntry
	(*ValidateVolumeCapabilitiesResponse_Confirmed)(nil), // 109: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed
	nil,                                      // 110: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.VolumeContextEntry
	nil,                                      // 111: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.ParametersEntry
	nil,                                      // 112: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.MutableParametersEntry
	(*ListVolumesResponse_VolumeStatus)(nil), // 113: csi.v1.ListVolumesResponse.VolumeStatus
	(*ListVolumesResponse_Entry)(nil),        // 114: csi.v1.ListVolumesResponse.Entry
	(*ControllerGetVolumeResponse_VolumeStatus)(nil), // 115: csi.v1.ControllerGetVolumeResponse.VolumeStatus
	nil,                                     // 116: csi.v1.ControllerModifyVolumeRequest.SecretsEntry
	nil,                                     // 117: csi.v1.ControllerModifyVolumeRequest.MutableParametersEntry
	nil,                                     // 118: csi.v1.GetCapacityRequest.ParametersEntry
	(*ControllerServiceCapability_RPC)(nil), // 119: csi.v1.ControllerServiceCapability.RPC
	nil,                                     // 120: csi.v1.CreateSnapshotRequest.SecretsEntry
	nil,                                     // 121: csi.v1.CreateSnapshotRequest.ParametersEntry
	nil,                                     // 122: csi.v1.DeleteSnapshotRequest.SecretsEntry
	nil,                                     // 123: csi.v1.ListSnapshotsRequest.SecretsEntry
	(*ListSnapshotsResponse_Entry)(nil),     // 124: csi.v1.ListSnapshotsResponse.Entry
	nil,                                     // 125: csi.v1.GetSnapshotRequest.SecretsEntry
	nil,                                     // 126: csi.v1.ControllerExpandVolumeRequest.SecretsEntry
	nil,                                     // 127: csi.v1.NodeStageVolumeRequest.PublishContextEntry
	nil,                                     // 128: csi.v1.NodeStageVolumeRequest.SecretsEntry
	nil,                                     // 129: csi.v1.NodeStageVolumeRequest.VolumeContextEntry
	nil,                                     // 130: csi.v1.NodePublishVolumeRequest.PublishContextEntry
	nil,                                     // 131: csi.v1.NodePublishVolumeRequest.SecretsEntry
	nil,                                     // 132: csi.v1.NodePublishVolumeRequest.VolumeContextEntry
	(*NodeServiceCapability_RPC)(nil),       // 133: csi.v1.NodeServiceCapability.RPC
	nil,                                     // 134: csi.v1.NodeExpandVolumeRequest.SecretsEntry
	(*GroupControllerServiceCapability_RPC)(nil), // 135: csi.v1.GroupControllerServiceCapability.RPC
	nil,                                 // 136: csi.v1.CreateVolumeGroupSnapshotRequest.SecretsEntry
	nil,                                 // 137: csi.v1.CreateVolumeGroupSnapshotRequest.ParametersEntry
	nil,                                 // 138: csi.v1.DeleteVolumeGroupSnapshotRequest.SecretsEntry
	nil,                                 // 139: csi.v1.GetVolumeGroupSnapshotRequest.SecretsEntry
	nil,                                 // 140: csi.v1.GetMetadataAllocatedRequest.SecretsEntry
	nil,                                 // 141: csi.v1.GetMetadataDeltaRequest.SecretsEntry
	(*wrappers.BoolValue)(nil),          // 142: google.protobuf.BoolValue
	(*wrappers.Int64Value)(nil),         // 143: google.protobuf.Int64Value
	(*timestamp.Timestamp)(nil),         // 144: google.protobuf.Timestamp
	(*descriptor.EnumOptions)(nil),      // 145: google.protobuf.EnumOptions
	(*descriptor.EnumValueOptions)(nil), // 146: google.protobuf.EnumValueOptions
	(*descriptor.FieldOptions)(nil),     // 147: google.protobuf.FieldOptions
	(*descriptor.MessageOptions)(nil),   // 148: google.protobuf.MessageOptions
	(*descriptor.MethodOptions)(nil),    // 149: google.protobuf.MethodOptions
	(*descriptor.ServiceOptions)(nil),   // 150: google.protobuf.ServiceOptions
}
var file_csi_proto_depIdxs = []int32{
	87,  // 0: csi.v1.GetPluginInfoResponse.manifest:type_name -> csi.v1.GetPluginInfoResponse.ManifestEntry
	12,  // 1: csi.v1.GetPluginCapabilitiesResponse.capabilities:type_name -> csi.v1.PluginCapability
	88,  // 2: csi.v1.PluginCapability.service:type_name -> csi.v1.PluginCapability.Service
	89,  // 3: csi.v1.PluginCapability.volume_expansion:type_name -> csi.v1.PluginCapability.VolumeExpansion
	142, // 4: csi.v1.ProbeResponse.ready:type_name -> google.protobuf.BoolValue
	19,  // 5: csi.v1.CreateVolumeRequest.capacity_range:type_name -> csi.v1.CapacityRange
	18,  // 6: csi.v1.CreateVolumeRequest.volume_capabilities:type_name -> csi.v1.VolumeCapability
	90,  // 7: csi.v1.CreateVolumeRequest.parameters:type_name -> csi.v1.CreateVolumeRequest.ParametersEntry
	91,  // 8: csi.v1.CreateVolumeRequest.secrets:type_name -> csi.v1.CreateVolumeRequest.SecretsEntry
	16,  // 9: csi.v1.CreateVolumeRequest.volume_content_source:type_name -> csi.v1.VolumeContentSource
	21,  // 10: csi.v1.CreateVolumeRequest.accessibility_requirements:type_name -> csi.v1.TopologyRequirement
	92,  // 11: csi.v1.CreateVolumeRequest.mutable_parameters:type_name -> csi.v1.CreateVolumeRequest.MutableParametersEntry
	93,  // 12: csi.v1.VolumeContentSource.snapshot:type_name -> csi.v1.VolumeContentSource.SnapshotSource
	94,  // 13: csi.v1.VolumeContentSource.volume:type_name -> csi.v1.VolumeContentSource.VolumeSource
	20,  // 14: csi.v1.CreateVolumeResponse.volume:type_name -> csi.v1.Volume
	95,  // 15: csi.v1.VolumeCapability.block:type_name -> csi.v1.VolumeCapability.BlockVolume
	96,  // 16: csi.v1.VolumeCapability.mount:type_name -> csi.v1.VolumeCapability.MountVolume
	97,  // 17: csi.v1.VolumeCapability.access_mode:type_name -> csi.v1.VolumeCapability.AccessMode
	98,  // 18: csi.v1.Volume.volume_context:type_name -> csi.v1.Volume.VolumeContextEntry
	16,  // 19: csi.v1.Volume.content_source:type_name -> csi.v1.VolumeContentSource
	22,  // 20: csi.v1.Volume.accessible_topology:type_name -> csi.v1.Topology
	22,  // 21: csi.v1.TopologyRequirement.requisite:type_name -> csi.v1.Topology
	22,  // 22: csi.v1.TopologyRequirement.preferred:type_name -> csi.v1.Topology
	99,  // 23: csi.v1.Topology.segments:type_name -> csi.v1.Topology.SegmentsEntry
	100, // 24: csi.v1.DeleteVolumeRequest.secrets:type_name -> csi.v1.DeleteVolumeRequest.SecretsEntry
	18,  // 25: csi.v1.ControllerPublishVolumeRequest.volume_capability:type_name -> csi.v1.VolumeCapability
	101, // 26: csi.v1.ControllerPublishVolumeRequest.secrets:type_name -> csi.v1.ControllerPublishVolumeRequest.SecretsEntry
	102, // 27: csi.v1.ControllerPublishVolumeRequest.volume_context:type_name -> csi.v1.ControllerPublishVolumeRequest.VolumeContextEntry
	103, // 28: csi.v1.ControllerPublishVolumeResponse.publish_context:type_name -> csi.v1.ControllerPublishVolumeResponse.PublishContextEntry
	104, // 29: csi.v1.ControllerUnpublishVolumeRequest.secrets:type_name -> csi.v1.ControllerUnpublishVolumeRequest.SecretsEntry
	105, // 30: csi.v1.ValidateVolumeCapabilitiesRequest.volume_context:type_name -> csi.v1.ValidateVolumeCapabilitiesRequest.VolumeContextEntry
	18,  // 31: csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities:type_name -> csi.v1.VolumeCapability
	106, // 32: csi.v1.ValidateVolumeCapabilitiesRequest.parameters:type_name -> csi.v1.ValidateVolumeCapabilitiesRequest.ParametersEntry
	107, // 33: csi.v1.ValidateVolumeCapabilitiesRequest.secrets:type_name -> csi.v1.ValidateVolumeCapabilitiesRequest.SecretsEntry
	108, // 34: csi.v1.ValidateVolumeCapabilitiesRequest.mutable_parameters:type_name -> csi.v1.ValidateVolumeCapabilitiesRequest.MutableParametersEntry
	109, // 35: csi.v1.ValidateVolumeCapabilitiesResponse.confirmed:type_name -> csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed
	114, // 36: csi.v1.ListVolumesResponse.entries:type_name -> csi.v1.ListVolumesResponse.Entry
	20,  // 37: csi.v1.ControllerGetVolumeResponse.volume:type_name -> csi.v1.Volume
	115, // 38: csi.v1.ControllerGetVolumeResponse.status:type_name -> csi.v1.ControllerGetVolumeResponse.VolumeStatus
	116, // 39: csi.v1.ControllerModifyVolumeRequest.secrets:type_name -> csi.v1.ControllerModifyVolumeRequest.SecretsEntry
	117, // 40: csi.v1.ControllerModifyVolumeRequest.mutable_parameters:type_name -> csi.v1.ControllerModifyVolumeRequest.MutableParametersEntry
	18,  // 41: csi.v1.GetCapacityRequest.volume_capabilities:type_name -> csi.v1.VolumeCapability
	118, // 42: csi.v1.GetCapacityRequest.parameters:type_name -> csi.v1.GetCapacityRequest.ParametersEntry
	22,  // 43: csi.v1.GetCapacityRequest.accessible_topology:type_name -> csi.v1.Topology
	143, // 44: csi.v1.GetCapacityResponse.maximum_volume_size:type_name -> google.protobuf.Int64Value
	143, // 45: csi.v1.GetCapacityResponse.minimum_volume_size:type_name -> google.protobuf.Int64Value
	41,  // 46: csi.v1.ControllerGetCapabilitiesResponse.capabilities:type_name -> csi.v1.ControllerServiceCapability
	119, // 47: csi.v1.ControllerServiceCapability.rpc:type_name -> csi.v1.ControllerServiceCapability.RPC
	120, // 48: csi.v1.CreateSnapshotRequest.secrets:type_name -> csi.v1.CreateSnapshotRequest.SecretsEntry
	121, // 49: csi.v1.CreateSnapshotRequest.parameters:type_name -> csi.v1.CreateSnapshotRequest.ParametersEntry
	44,  // 50: csi.v1.CreateSnapshotResponse.snapshot:type_name -> csi.v1.Snapshot
	144, // 51: csi.v1.Snapshot.creation_time:type_name -> google.protobuf.Timestamp
	122, // 52: csi.v1.DeleteSnapshotRequest.secrets:type_name -> csi.v1.DeleteSnapshotRequest.SecretsEntry
	123, // 53: csi.v1.ListSnapshotsRequest.secrets:type_name -> csi.v1.ListSnapshotsRequest.SecretsEntry
	124, // 54: csi.v1.ListSnapshotsResponse.entries:type_name -> csi.v1.ListSnapshotsResponse.Entry
	125, // 55: csi.v1.GetSnapshotRequest.secrets:type_name -> csi.v1.GetSnapshotRequest.SecretsEntry
	44,  // 56: csi.v1.GetSnapshotResponse.snapshot:type_name -> csi.v1.Snapshot
	19,  // 57: csi.v1.ControllerExpandVolumeRequest.capacity_range:type_name -> csi.v1.CapacityRange
	126, // 58: csi.v1.ControllerExpandVolumeRequest.secrets:type_name -> csi.v1.ControllerExpandVolumeRequest.SecretsEntry
	18,  // 59: csi.v1.ControllerExpandVolumeRequest.volume_capability:type_name -> csi.v1.VolumeCapability
	127, // 60: csi.v1.NodeStageVolumeRequest.publish_context:type_name -> csi.v1.NodeStageVolumeRequest.PublishContextEntry
	18,  // 61: csi.v1.NodeStageVolumeRequest.volume_capability:type_name -> csi.v1.VolumeCapability
	128, // 62: csi.v1.NodeStageVolumeRequest.secrets:type_name -> csi.v1.NodeStageVolumeRequest.SecretsEntry
	129, // 63: csi.v1.NodeStageVolumeRequest.volume_context:type_name -> csi.v1.NodeStageVolumeRequest.VolumeContextEntry
	130, // 64: csi.v1.NodePublishVolumeRequest.publish_context:type_name -> csi.v1.NodePublishVolumeRequest.PublishContextEntry
	18,  // 65: csi.v1.NodePublishVolumeRequest.volume_capability:type_name -> csi.v1.VolumeCapability
	131, // 66: csi.v1.NodePublishVolumeRequest.secrets:type_name -> csi.v1.NodePublishVolumeRequest.SecretsEntry
	132, // 67: csi.v1.NodePublishVolumeRequest.volume_context:type_name -> csi.v1.NodePublishVolumeRequest.VolumeContextEntry
	63,  // 68: csi.v1.NodeGetVolumeStatsResponse.usage:type_name -> csi.v1.VolumeUsage
	64,  // 69: csi.v1.NodeGetVolumeStatsResponse.volume_condition:type_name -> csi.v1.VolumeCondition
	5,   // 70: csi.v1.VolumeUsage.unit:type_name -> csi.v1.VolumeUsage.Unit
	67,  // 71: csi.v1.NodeGetCapabilitiesResponse.capabilities:type_name -> csi.v1.NodeServiceCapability
	133, // 72: csi.v1.NodeServiceCapability.rpc:type_name -> csi.v1.NodeServiceCapability.RPC
	22,  // 73: csi.v1.NodeGetInfoResponse.accessible_topology:type_name -> csi.v1.Topology
	19,  // 74: csi.v1.NodeExpandVolumeRequest.capacity_range:type_name -> csi.v1.CapacityRange
	18,  // 75: csi.v1.NodeExpandVolumeRequest.volume_capability:type_name -> csi.v1.VolumeCapability
	134, // 76: csi.v1.NodeExpandVolumeRequest.secrets:type_name -> csi.v1.NodeExpandVolumeRequest.SecretsEntry
	74,  // 77: csi.v1.GroupControllerGetCapabilitiesResponse.capabilities:type_name -> csi.v1.GroupControllerServiceCapability
	135, // 78: csi.v1.GroupControllerServiceCapability.rpc:type_name -> csi.v1.GroupControllerServiceCapability.RPC
	136, // 79: csi.v1.CreateVolumeGroupSnapshotRequest.secrets:type_name -> csi.v1.CreateVolumeGroupSnapshotRequest.SecretsEntry
	137, // 80: csi.v1.CreateVolumeGroupSnapshotRequest.parameters:type_name -> csi.v1.CreateVolumeGroupSnapshotRequest.ParametersEntry
	77,  // 81: csi.v1.CreateVolumeGroupSnapshotResponse.group_snapshot:type_name -> csi.v1.VolumeGroupSnapshot
	44,  // 82: csi.v1.VolumeGroupSnapshot.snapshots:type_name -> csi.v1.Snapshot
	144, // 83: csi.v1.VolumeGroupSnapshot.creation_time:type_name -> google.protobuf.Timestamp
	138, // 84: csi.v1.DeleteVolumeGroupSnapshotRequest.secrets:type_name -> csi.v1.DeleteVolumeGroupSnapshotRequest.SecretsEntry
	139, // 85: csi.v1.GetVolumeGroupSnapshotRequest.secrets:type_name -> csi.v1.GetVolumeGroupSnapshotRequest.SecretsEntry
	77,  // 86: csi.v1.GetVolumeGroupSnapshotResponse.group_snapshot:type_name -> csi.v1.VolumeGroupSnapshot
	140, // 87: csi.v1.GetMetadataAllocatedRequest.secrets:type_name -> csi.v1.GetMetadataAllocatedRequest.SecretsEntry
	0,   // 88: csi.v1.GetMetadataAllocatedResponse.block_metadata_type:type_name -> csi.v1.BlockMetadataType
	82,  // 89: csi.v1.GetMetadataAllocatedResponse.block_metadata:type_name -> csi.v1.BlockMetadata
	141, // 90: csi.v1.GetMetadataDeltaRequest.secrets:type_name -> csi.v1.GetMetadataDeltaRequest.SecretsEntry
	0,   // 91: csi.v1.GetMetadataDeltaResponse.block_metadata_type:type_name -> csi.v1.BlockMetadataType
	82,  // 92: csi.v1.GetMetadataDeltaResponse.block_metadata:type_name -> csi.v1.BlockMetadata
	1,   // 93: csi.v1.PluginCapability.Service.type:type_name -> csi.v1.PluginCapability.Service.Type
	2,   // 94: csi.v1.PluginCapability.VolumeExpansion.type:type_name -> csi.v1.PluginCapability.VolumeExpansion.Type
	3,   // 95: csi.v1.VolumeCapability.AccessMode.mode:type_name -> csi.v1.VolumeCapability.AccessMode.Mode
	110, // 96: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_context:type_name -> csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.VolumeContextEntry
	18,  // 97: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities:type_name -> csi.v1.VolumeCapability
	111, // 98: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.parameters:type_name -> csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.ParametersEntry
	112, // 99: csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.mutable_parameters:type_name -> csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.MutableParametersEntry
	64,  // 100: csi.v1.ListVolumesResponse.VolumeStatus.volume_condition:type_name -> csi.v1.VolumeCondition
	20,  // 101: csi.v1.ListVolumesResponse.Entry.volume:type_name -> csi.v1.Volume
	113, // 102: csi.v1.ListVolumesResponse.Entry.status:type_name -> csi.v1.ListVolumesResponse.VolumeStatus
	64,  // 103: csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition:type_name -> csi.v1.VolumeCondition
	4,   // 104: csi.v1.ControllerServiceCapability.RPC.type:type_name -> csi.v1.ControllerServiceCapability.RPC.Type
	44,  // 105: csi.v1.ListSnapshotsResponse.Entry.snapshot:type_name -> csi.v1.Snapshot
	6,   // 106: csi.v1.NodeServiceCapability.RPC.type:type_name -> csi.v1.NodeServiceCapability.RPC.Type
	7,   // 107: csi.v1.GroupControllerServiceCapability.RPC.type:type_name -> csi.v1.GroupControllerServiceCapability.RPC.Type
	145, // 108: csi.v1.alpha_enum:extendee -> google.protobuf.EnumOptions
	146, // 109: csi.v1.alpha_enum_value:extendee -> google.protobuf.EnumValueOptions
	147, // 110: csi.v1.csi_secret:extendee -> google.protobuf.FieldOptions
	147, // 111: csi.v1.alpha_field:extendee -> google.protobuf.FieldOptions
	148, // 112: csi.v1.alpha_message:extendee -> google.protobuf.MessageOptions
	149, // 113: csi.v1.alpha_method:extendee -> google.protobuf.MethodOptions
	150, // 114: csi.v1.alpha_service:extendee -> google.protobuf.ServiceOptions
	8,   // 115: csi.v1.Identity.GetPluginInfo:input_type -> csi.v1.GetPluginInfoRequest
	10,  // 116: csi.v1.Identity.GetPluginCapabilities:input_type -> csi.v1.GetPluginCapabilitiesRequest
	13,  // 117: csi.v1.Identity.Probe:input_type -> csi.v1.ProbeRequest
	15,  // 118: csi.v1.Controller.CreateVolume:input_type -> csi.v1.CreateVolumeRequest
	23,  // 119: csi.v1.Controller.DeleteVolume:input_type -> csi.v1.DeleteVolumeRequest
	25,  // 120: csi.v1.Controller.ControllerPublishVolume:input_type -> csi.v1.ControllerPublishVolumeRequest
	27,  // 121: csi.v1.Controller.ControllerUnpublishVolume:input_type -> csi.v1.ControllerUnpublishVolumeRequest
	29,  // 122: csi.v1.Controller.ValidateVolumeCapabilities:input_type -> csi.v1.ValidateVolumeCapabilitiesRequest
	31,  // 123: csi.v1.Controller.ListVolumes:input_type -> csi.v1.ListVolumesRequest
	37,  // 124: csi.v1.Controller.GetCapacity:input_type -> csi.v1.GetCapacityRequest
	39,  // 125: csi.v1.Controller.ControllerGetCapabilities:input_type -> csi.v1.ControllerGetCapabilitiesRequest
	42,  // 126: csi.v1.Controller.CreateSnapshot:input_type -> csi.v1.CreateSnapshotRequest
	45,  // 127: csi.v1.Controller.DeleteSnapshot:input_type -> csi.v1.DeleteSnapshotRequest
	47,  // 128: csi.v1.Controller.ListSnapshots:input_type -> csi.v1.ListSnapshotsRequest
	49,  // 129: csi.v1.Controller.GetSnapshot:input_type -> csi.v1.GetSnapshotRequest
	51,  // 130: csi.v1.Controller.ControllerExpandVolume:input_type -> csi.v1.ControllerExpandVolumeRequest
	33,  // 131: csi.v1.Controller.ControllerGetVolume:input_type -> csi.v1.ControllerGetVolumeRequest
	35,  // 132: csi.v1.Controller.ControllerModifyVolume:input_type -> csi.v1.ControllerModifyVolumeRequest
	72,  // 133: csi.v1.GroupController.GroupControllerGetCapabilities:input_type -> csi.v1.GroupControllerGetCapabilitiesRequest
	75,  // 134: csi.v1.GroupController.CreateVolumeGroupSnapshot:input_type -> csi.v1.CreateVolumeGroupSnapshotRequest
	78,  // 135: csi.v1.GroupController.DeleteVolumeGroupSnapshot:input_type -> csi.v1.DeleteVolumeGroupSnapshotRequest
	80,  // 136: csi.v1.GroupController.GetVolumeGroupSnapshot:input_type -> csi.v1.GetVolumeGroupSnapshotRequest
	83,  // 137: csi.v1.SnapshotMetadata.GetMetadataAllocated:input_type -> csi.v1.GetMetadataAllocatedRequest
	85,  // 138: csi.v1.SnapshotMetadata.GetMetadataDelta:input_type -> csi.v1.GetMetadataDeltaRequest
	53,  // 139: csi.v1.Node.NodeStageVolume:input_type -> csi.v1.NodeStageVolumeRequest
	55,  // 140: csi.v1.Node.NodeUnstageVolume:input_type -> csi.v1.NodeUnstageVolumeRequest
	57,  // 141: csi.v1.Node.NodePublishVolume:input_type -> csi.v1.NodePublishVolumeRequest
	59,  // 142: csi.v1.Node.NodeUnpublishVolume:input_type -> csi.v1.NodeUnpublishVolumeRequest
	61,  // 143: csi.v1.Node.NodeGetVolumeStats:input_type -> csi.v1.NodeGetVolumeStatsRequest
	70,  // 144: csi.v1.Node.NodeExpandVolume:input_type -> csi.v1.NodeExpandVolumeRequest
	65,  // 145: csi.v1.Node.NodeGetCapabilities:input_type -> csi.v1.NodeGetCapabilitiesRequest
	68,  // 146: csi.v1.Node.NodeGetInfo:input_type -> csi.v1.NodeGetInfoRequest
	9,   // 147: csi.v1.Identity.GetPluginInfo:output_type -> csi.v1.GetPluginInfoResponse
	11,  // 148: csi.v1.Identity.GetPluginCapabilities:output_type -> csi.v1.GetPluginCapabilitiesResponse
	14,  // 149: csi.v1.Identity.Probe:output_type -> csi.v1.ProbeResponse
	17,  // 150: csi.v1.Controller.CreateVolume:output_type -> csi.v1.CreateVolumeResponse
	24,  // 151: csi.v1.Controller.DeleteVolume:output_type -> csi.v1.DeleteVolumeResponse
	26,  // 152: csi.v1.Controller.ControllerPublishVolume:output_type -> csi.v1.ControllerPublishVolumeResponse
	28,  // 153: csi.v1.Controller.ControllerUnpublishVolume:output_type -> csi.v1.ControllerUnpublishVolumeResponse
	30,  // 154: csi.v1.Controller.ValidateVolumeCapabilities:output_type -> csi.v1.ValidateVolumeCapabilitiesResponse
	32,  // 155: csi.v1.Controller.ListVolumes:output_type -> csi.v1.ListVolumesResponse
	38,  // 156: csi.v1.Controller.GetCapacity:output_type -> csi.v1.GetCapacityResponse
	40,  // 157: csi.v1.Controller.ControllerGetCapabilities:output_type -> csi.v1.ControllerGetCapabilitiesResponse
	43,  // 158: csi.v1.Controller.CreateSnapshot:output_type -> csi.v1.CreateSnapshotResponse
	46,  // 159: csi.v1.Controller.DeleteSnapshot:output_type -> csi.v1.DeleteSnapshotResponse
	48,  // 160: csi.v1.Controller.ListSnapshots:output_type -> csi.v1.ListSnapshotsResponse
	50,  // 161: csi.v1.Controller.GetSnapshot:output_type -> csi.v1.GetSnapshotResponse
	52,  // 162: csi.v1.Controller.ControllerExpandVolume:output_type -> csi.v1.ControllerExpandVolumeResponse
	34,  // 163: csi.v1.Controller.ControllerGetVolume:output_type -> csi.v1.ControllerGetVolumeResponse
	36,  // 164: csi.v1.Controller.ControllerModifyVolume:output_type -> csi.v1.ControllerModifyVolumeResponse
	73,  // 165: csi.v1.GroupController.GroupControllerGetCapabilities:output_type -> csi.v1.GroupControllerGetCapabilitiesResponse
	76,  // 166: csi.v1.GroupController.CreateVolumeGroupSnapshot:output_type -> csi.v1.CreateVolumeGroupSnapshotResponse
	79,  // 167: csi.v1.GroupController.DeleteVolumeGroupSnapshot:output_type -> csi.v1.DeleteVolumeGroupSnapshotResponse
	81,  // 168: csi.v1.GroupController.GetVolumeGroupSnapshot:output_type -> csi.v1.GetVolumeGroupSnapshotResponse
	84,  // 169: csi.v1.SnapshotMetadata.GetMetadataAllocated:output_type -> csi.v1.GetMetadataAllocatedResponse
	86,  // 170: csi.v1.SnapshotMetadata.GetMetadataDelta:output_type -> csi.v1.GetMetadataDeltaResponse
	54,  // 171: csi.v1.Node.NodeStageVolume:output_type -> csi.v1.NodeStageVolumeResponse
	56,  // 172: csi.v1.Node.NodeUnstageVolume:output_type -> csi.v1.NodeUnstageVolumeResponse
	58,  // 173: csi.v1.Node.NodePublishVolume:output_type -> csi.v1.NodePublishVolumeResponse
	60,  // 174: csi.v1.Node.NodeUnpublishVolume:output_type -> csi.v1.NodeUnpublishVolumeResponse
	62,  // 175: csi.v1.Node.NodeGetVolumeStats:output_type -> csi.v1.NodeGetVolumeStatsResponse
	71,  // 176: csi.v1.Node.NodeExpandVolume:output_type -> csi.v1.NodeExpandVolumeResponse
	66,  // 177: csi.v1.Node.NodeGetCapabilities:output_type -> csi.v1.NodeGetCapabilitiesResponse
	69,  // 178: csi.v1.Node.NodeGetInfo:output_type -> csi.v1.NodeGetInfoResponse
	147, // [147:179] is the sub-list for method output_type
	115, // [115:147] is the sub-list for method input_type
	115, // [115:115] is the sub-list for extension type_name
	108, // [108:115] is the sub-list for extension extendee
	0,   // [0:108] is the sub-list for field type_name
}

func init() { file_csi_proto_init() }
func file_csi_proto_init() {
	if File_csi_proto != nil {
		return
	}
	file_csi_proto_msgTypes[4].OneofWrappers = []any{
		(*PluginCapability_Service_)(nil),
		(*PluginCapability_VolumeExpansion_)(nil),
	}
	file_csi_proto_msgTypes[8].OneofWrappers = []any{
		(*VolumeContentSource_Snapshot)(nil),
		(*VolumeContentSource_Volume)(nil),
	}
	file_csi_proto_msgTypes[10].OneofWrappers = []any{
		(*VolumeCapability_Block)(nil),
		(*VolumeCapability_Mount)(nil),
	}
	file_csi_proto_msgTypes[33].OneofWrappers = []any{
		(*ControllerServiceCapability_Rpc)(nil),
	}
	file_csi_proto_msgTypes[59].OneofWrappers = []any{
		(*NodeServiceCapability_Rpc)(nil),
	}
	file_csi_proto_msgTypes[66].OneofWrappers = []any{
		(*GroupControllerServiceCapability_Rpc)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_csi_proto_rawDesc), len(file_csi_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   134,
			NumExtensions: 7,
			NumServices:   5,
		},
		GoTypes:           file_csi_proto_goTypes,
		DependencyIndexes: file_csi_proto_depIdxs,
		EnumInfos:         file_csi_proto_enumTypes,
		MessageInfos:      file_csi_proto_msgTypes,
		ExtensionInfos:    file_csi_proto_extTypes,
	}.Build()
	File_csi_proto = out.File
	file_csi_proto_goTypes = nil
	file_csi_proto_depIdxs = nil
}
